{"version":3,"file":"index.mjs","sources":["../node_modules/diff-dom/src/diffDOM.js","../src/util/compareArray.ts","../src/util/matchEl.ts","../src/util/domParser.ts","../src/util/replaceDom.ts","../src/util/selectDom.ts","../src/util/filterObject.ts","../src/hooks/store.ts","../src/core/Component.ts","../src/core/render.ts","../src/hooks/useState.ts","../src/util/insertBefore.ts","../src/util/insertAfter.ts","../src/util/removeDom.ts","../src/hooks/useEffect.ts","../src/hooks/register.ts"],"sourcesContent":["let diffcount\nlet foundAll = false\n\nclass Diff {\n    constructor(options = {}) {\n        Object.entries(options).forEach(([key, value]) => this[key] = value)\n    }\n\n    toString() {\n        return JSON.stringify(this)\n    }\n\n    setValue(aKey, aValue) {\n        this[aKey] = aValue\n        return this\n    }\n}\n\nfunction elementDescriptors(el) {\n    const output = []\n    if (el.nodeName !== '#text' && el.nodeName !== '#comment') {\n        output.push(el.nodeName)\n        if (el.attributes) {\n            if (el.attributes['class']) {\n                output.push(`${el.nodeName}.${el.attributes['class'].replace(/ /g, '.')}`)\n            }\n            if (el.attributes.id) {\n                output.push(`${el.nodeName}#${el.attributes.id}`)\n            }\n        }\n\n    }\n    return output\n}\n\nfunction findUniqueDescriptors(li) {\n    const uniqueDescriptors = {}\n    const duplicateDescriptors = {}\n\n    li.forEach(node => {\n        elementDescriptors(node).forEach(descriptor => {\n            const inUnique = descriptor in uniqueDescriptors\n            const inDupes = descriptor in duplicateDescriptors\n            if (!inUnique && !inDupes) {\n                uniqueDescriptors[descriptor] = true\n            } else if (inUnique) {\n                delete uniqueDescriptors[descriptor]\n                duplicateDescriptors[descriptor] = true\n            }\n        })\n    })\n\n    return uniqueDescriptors\n}\n\nfunction uniqueInBoth(l1, l2) {\n    const l1Unique = findUniqueDescriptors(l1)\n    const l2Unique = findUniqueDescriptors(l2)\n    const inBoth = {}\n\n    Object.keys(l1Unique).forEach(key => {\n        if (l2Unique[key]) {\n            inBoth[key] = true\n        }\n    })\n\n    return inBoth\n}\n\nfunction removeDone(tree) {\n    delete tree.outerDone\n    delete tree.innerDone\n    delete tree.valueDone\n    if (tree.childNodes) {\n        return tree.childNodes.every(removeDone)\n    } else {\n        return true\n    }\n}\n\nfunction isEqual(e1, e2) {\n    if (!['nodeName', 'value', 'checked', 'selected', 'data'].every(element => {\n            if (e1[element] !== e2[element]) {\n                return false\n            }\n            return true\n        })) {\n        return false\n    }\n\n    if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\n        return false\n    }\n\n    if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\n        return false\n    }\n    if (e1.attributes) {\n        const e1Attributes = Object.keys(e1.attributes)\n        const e2Attributes = Object.keys(e2.attributes)\n\n        if (e1Attributes.length !== e2Attributes.length) {\n            return false\n        }\n        if (!e1Attributes.every(attribute => {\n                if (e1.attributes[attribute] !== e2.attributes[attribute]) {\n                    return false\n                }\n                return true\n            })) {\n            return false\n        }\n    }\n    if (e1.childNodes) {\n        if (e1.childNodes.length !== e2.childNodes.length) {\n            return false\n        }\n        if (!e1.childNodes.every((childNode, index) => isEqual(childNode, e2.childNodes[index]))) {\n\n            return false\n        }\n\n    }\n\n    return true\n}\n\n\nfunction roughlyEqual(e1, e2, uniqueDescriptors, sameSiblings, preventRecursion) {\n\n    if (!e1 || !e2) {\n        return false\n    }\n\n    if (e1.nodeName !== e2.nodeName) {\n        return false\n    }\n\n    if (e1.nodeName === '#text') {\n        // Note that we initially don't care what the text content of a node is,\n        // the mere fact that it's the same tag and \"has text\" means it's roughly\n        // equal, and then we can find out the true text difference later.\n        return preventRecursion ? true : e1.data === e2.data\n    }\n\n\n    if (e1.nodeName in uniqueDescriptors) {\n        return true\n    }\n\n    if (e1.attributes && e2.attributes) {\n\n        if (e1.attributes.id) {\n            if (e1.attributes.id !== e2.attributes.id) {\n                return false\n            } else {\n                const idDescriptor = `${e1.nodeName}#${e1.attributes.id}`\n                if (idDescriptor in uniqueDescriptors) {\n                    return true\n                }\n            }\n        }\n        if (e1.attributes['class'] && e1.attributes['class'] === e2.attributes['class']) {\n            const classDescriptor = `${e1.nodeName}.${e1.attributes['class'].replace(/ /g, '.')}`\n            if (classDescriptor in uniqueDescriptors) {\n                return true\n            }\n        }\n    }\n\n    if (sameSiblings) {\n        return true\n    }\n\n    const nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : []\n    const nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : []\n\n    if (nodeList1.length !== nodeList2.length) {\n        return false\n    }\n\n    if (preventRecursion) {\n        return nodeList1.every((element, index) => element.nodeName === nodeList2[index].nodeName)\n    } else {\n        // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n        // was not set, we must explicitly force it to true for child iterations.\n        const childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2)\n        return nodeList1.every((element, index) => roughlyEqual(element, nodeList2[index], childUniqueDescriptors, true, true))\n    }\n}\n\n\nfunction cloneObj(obj) { //  TODO: Do we really need to clone here? Is it not enough to just return the original object?\n    return JSON.parse(JSON.stringify(obj))\n}\n/**\n * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n */\nfunction findCommonSubsets(c1, c2, marked1, marked2) {\n    let lcsSize = 0\n    let index = []\n    const c1Length = c1.length\n    const c2Length = c2.length\n\n    const // set up the matching table\n        matches = Array(...new Array(c1Length + 1)).map(() => [])\n\n    const uniqueDescriptors = uniqueInBoth(c1, c2)\n\n    let // If all of the elements are the same tag, id and class, then we can\n        // consider them roughly the same even if they have a different number of\n        // children. This will reduce removing and re-adding similar elements.\n        subsetsSame = c1Length === c2Length\n\n    if (subsetsSame) {\n\n        c1.some((element, i) => {\n            const c1Desc = elementDescriptors(element)\n            const c2Desc = elementDescriptors(c2[i])\n            if (c1Desc.length !== c2Desc.length) {\n                subsetsSame = false\n                return true\n            }\n            c1Desc.some((description, i) => {\n                if (description !== c2Desc[i]) {\n                    subsetsSame = false\n                    return true\n                }\n            })\n            if (!subsetsSame) {\n                return true\n            }\n        })\n    }\n\n    // fill the matches with distance values\n    for (let c1Index = 0; c1Index < c1Length; c1Index++) {\n        const c1Element = c1[c1Index]\n        for (let c2Index = 0; c2Index < c2Length; c2Index++) {\n            const c2Element = c2[c2Index]\n            if (!marked1[c1Index] && !marked2[c2Index] && roughlyEqual(c1Element, c2Element, uniqueDescriptors, subsetsSame)) {\n                matches[c1Index + 1][c2Index + 1] = (matches[c1Index][c2Index] ? matches[c1Index][c2Index] + 1 : 1)\n                if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\n                    lcsSize = matches[c1Index + 1][c2Index + 1]\n                    index = [c1Index + 1, c2Index + 1]\n                }\n            } else {\n                matches[c1Index + 1][c2Index + 1] = 0\n            }\n        }\n    }\n\n    if (lcsSize === 0) {\n        return false\n    }\n\n    return {\n        oldValue: index[0] - lcsSize,\n        newValue: index[1] - lcsSize,\n        length: lcsSize\n    }\n}\n\n/**\n * This should really be a predefined function in Array...\n */\nfunction makeArray(n, v) {\n    return Array(...new Array(n)).map(() => v)\n}\n\n/**\n * Generate arrays that indicate which node belongs to which subset,\n * or whether it's actually an orphan node, existing in only one\n * of the two trees, rather than somewhere in both.\n *\n * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n * The second longest is \"<img>\" (length 1), so it will be group 1.\n * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n *\n * If an element is not part of any group, it will stay being 'true', which\n * is the initial value. For example:\n * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n *\n * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n * therefore be marked by \"true\". The remaining parts are parts of the\n * groups 0 and 1:\n * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n *\n */\nfunction getGapInformation(t1, t2, stable) {\n    const gaps1 = t1.childNodes ? makeArray(t1.childNodes.length, true) : []\n    const gaps2 = t2.childNodes ? makeArray(t2.childNodes.length, true) : []\n    let group = 0\n\n    // give elements from the same subset the same group number\n    stable.forEach(subset => {\n        const endOld = subset.oldValue + subset.length\n        const endNew = subset.newValue + subset.length\n\n        for (let j = subset.oldValue; j < endOld; j += 1) {\n            gaps1[j] = group\n        }\n        for (let j = subset.newValue; j < endNew; j += 1) {\n            gaps2[j] = group\n        }\n        group += 1\n    })\n\n    return {\n        gaps1,\n        gaps2\n    }\n}\n\n/**\n * Find all matching subsets, based on immediate child differences only.\n */\nfunction markSubTrees(oldTree, newTree) {\n    // note: the child lists are views, and so update as we update old/newTree\n    const oldChildren = oldTree.childNodes ? oldTree.childNodes : []\n\n    const newChildren = newTree.childNodes ? newTree.childNodes : []\n    const marked1 = makeArray(oldChildren.length, false)\n    const marked2 = makeArray(newChildren.length, false)\n    const subsets = []\n    let subset = true\n\n    const returnIndex = function() {\n        return arguments[1]\n    }\n\n    const markBoth = i => {\n        marked1[subset.oldValue + i] = true\n        marked2[subset.newValue + i] = true\n    }\n\n    while (subset) {\n        subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2)\n        if (subset) {\n            subsets.push(subset)\n            const subsetArray = Array(...new Array(subset.length)).map(returnIndex)\n            subsetArray.forEach(item => markBoth(item))\n        }\n    }\n\n    oldTree.subsets = subsets\n    oldTree.subsetsAge = 100\n    return subsets\n}\n\n\nfunction swap(obj, p1, p2) {\n    const tmp = obj[p1]\n    obj[p1] = obj[p2]\n    obj[p2] = tmp\n}\n\n\nclass DiffTracker {\n    constructor() {\n        this.list = []\n    }\n\n    add(diffs) {\n        this.list.push(...diffs)\n    }\n    forEach(fn) {\n        this.list.forEach(li => fn(li))\n    }\n\n}\n\nexport class DiffDOM {\n    constructor({\n        debug = false,\n        diffcap = 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n        maxDepth = false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n        maxChildCount = 50, // False or a numeral. If set to a numeral, does not try to diff the contents of nodes with more children if there are more than maxChildDiffCount differences among child nodes.\n        maxChildDiffCount = 3, // Numeral. See maxChildCount.\n        valueDiffing = true, // Whether to take into consideration the values of forms that differ from auto assigned values (when a user fills out a form).\n        // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\n        textDiff = function() {\n            arguments[0].data = arguments[3]\n            return\n        },\n        // empty functions were benchmarked as running faster than both\n        // `f && f()` and `if (f) { f(); }`\n        preVirtualDiffApply = function() {},\n        postVirtualDiffApply = function() {},\n        preDiffApply = function() {},\n        postDiffApply = function() {},\n        filterOuterDiff = null,\n        compress = false // Whether to work with compressed diffs\n    }) {\n\n        this.debug = debug\n        this.diffcap = diffcap\n        this.maxDepth = maxDepth\n        this.maxChildCount = maxChildCount\n        this.maxChildDiffCount = maxChildDiffCount\n        this.valueDiffing = valueDiffing\n        this.textDiff = textDiff\n        this.preVirtualDiffApply = preVirtualDiffApply\n        this.postVirtualDiffApply = postVirtualDiffApply\n        this.preDiffApply = preDiffApply\n        this.postDiffApply = postDiffApply\n        this.filterOuterDiff = filterOuterDiff\n        this.compress = compress\n\n        const varNames = [\"addAttribute\", \"modifyAttribute\", \"removeAttribute\",\n            \"modifyTextElement\", \"relocateGroup\", \"removeElement\", \"addElement\",\n            \"removeTextElement\", \"addTextElement\", \"replaceElement\", \"modifyValue\",\n            \"modifyChecked\", \"modifySelected\", \"modifyComment\", \"action\", \"route\",\n            \"oldValue\", \"newValue\", \"element\", \"group\", \"from\", \"to\", \"name\",\n            \"value\", \"data\", \"attributes\", \"nodeName\", \"childNodes\", \"checked\",\n            \"selected\"\n        ]\n        this._const = {}\n        if (this.compress) {\n            varNames.forEach((varName, index) => this._const[varName] = index)\n        } else {\n            varNames.forEach(varName => this._const[varName] = varName)\n        }\n    }\n\n    // ===== Create a diff =====\n\n    diff(t1Node, t2Node) {\n        const t1 = this.nodeToObj(t1Node)\n        const t2 = this.nodeToObj(t2Node)\n\n        diffcount = 0\n\n        if (this.debug) {\n            this.t1Orig = this.nodeToObj(t1Node)\n            this.t2Orig = this.nodeToObj(t2Node)\n        }\n\n        this.tracker = new DiffTracker()\n        return this.findDiffs(t1, t2)\n    }\n\n    findDiffs(t1, t2) {\n        let diffs\n        do {\n            if (this.debug) {\n                diffcount += 1\n                if (diffcount > this.diffcap) {\n                    window.diffError = [this.t1Orig, this.t2Orig]\n                    throw new Error(`surpassed diffcap:${JSON.stringify(this.t1Orig)} -> ${JSON.stringify(this.t2Orig)}`)\n                }\n            }\n            diffs = this.findNextDiff(t1, t2, [])\n\n            if (diffs.length === 0) {\n                // Last check if the elements really are the same now.\n                // If not, remove all info about being done and start over.\n                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                if (!isEqual(t1, t2)) {\n                    if (foundAll) {\n                        console.error('Could not find remaining diffs!')\n                        console.log({\n                            t1,\n                            t2\n                        })\n                    } else {\n                        foundAll = true\n                        removeDone(t1)\n                        diffs = this.findNextDiff(t1, t2, [])\n                    }\n                }\n            }\n            if (diffs.length > 0) {\n                foundAll = false\n                this.tracker.add(diffs)\n                this.applyVirtual(t1, diffs)\n            }\n        } while (diffs.length > 0)\n        return this.tracker.list\n    }\n\n    findNextDiff(t1, t2, route) {\n        let diffs\n        let fdiffs\n\n        if (this.maxDepth && route.length > this.maxDepth) {\n            return []\n        }\n        // outer differences?\n        if (!t1.outerDone) {\n            diffs = this.findOuterDiff(t1, t2, route)\n            if (this.filterOuterDiff) {\n                fdiffs = this.filterOuterDiff(t1, t2, diffs)\n                if (fdiffs) diffs = fdiffs\n            }\n            if (diffs.length > 0) {\n                t1.outerDone = true\n                return diffs\n            } else {\n                t1.outerDone = true\n            }\n        }\n        // inner differences?\n        if (!t1.innerDone) {\n            diffs = this.findInnerDiff(t1, t2, route)\n            if (diffs.length > 0) {\n                return diffs\n            } else {\n                t1.innerDone = true\n            }\n        }\n\n        if (this.valueDiffing && !t1.valueDone) {\n            // value differences?\n            diffs = this.findValueDiff(t1, t2, route)\n\n            if (diffs.length > 0) {\n                t1.valueDone = true\n                return diffs\n            } else {\n                t1.valueDone = true\n            }\n        }\n\n        // no differences\n        return []\n    }\n\n    findOuterDiff(t1, t2, route) {\n        const diffs = []\n        let attr\n        let attr1\n        let attr2\n        let attrLength\n        let pos\n        let i\n\n        if (t1.nodeName !== t2.nodeName) {\n            return [new Diff()\n                .setValue(this._const.action, this._const.replaceElement)\n                .setValue(this._const.oldValue, cloneObj(t1))\n                .setValue(this._const.newValue, cloneObj(t2))\n                .setValue(this._const.route, route)\n            ]\n        }\n\n        if (route.length && this.maxChildCount && t1.childNodes && t2.childNodes && t1.childNodes.length > this.maxChildCount && t2.childNodes.length > this.maxChildCount) {\n            const childNodesLength = t1.childNodes.length < t2.childNodes.length ? t1.childNodes.length : t2.childNodes.length\n            let childDiffCount = 0\n            let j = 0\n            while (childDiffCount < this.maxChildDiffCount && j < childNodesLength) {\n                if (!isEqual(t1.childNodes[j], t2.childNodes[j])) {\n                    childDiffCount++\n                }\n                j++\n            }\n            if (childDiffCount === this.maxChildDiffCount) {\n                return [new Diff()\n                    .setValue(this._const.action, this._const.replaceElement)\n                    .setValue(this._const.oldValue, cloneObj(t1))\n                    .setValue(this._const.newValue, cloneObj(t2))\n                    .setValue(this._const.route, route)\n                ]\n            }\n        }\n\n        if (t1.data !== t2.data) {\n            // Comment or text node.\n            if (t1.nodeName === '#text') {\n                return [new Diff()\n                    .setValue(this._const.action, this._const.modifyTextElement)\n                    .setValue(this._const.route, route)\n                    .setValue(this._const.oldValue, t1.data)\n                    .setValue(this._const.newValue, t2.data)\n                ]\n            } else {\n                return [new Diff()\n                    .setValue(this._const.action, this._const.modifyComment)\n                    .setValue(this._const.route, route)\n                    .setValue(this._const.oldValue, t1.data)\n                    .setValue(this._const.newValue, t2.data)\n                ]\n            }\n\n        }\n\n\n        attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : []\n        attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : []\n\n        attrLength = attr1.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr1[i]\n            pos = attr2.indexOf(attr)\n            if (pos === -1) {\n                diffs.push(new Diff()\n                    .setValue(this._const.action, this._const.removeAttribute)\n                    .setValue(this._const.route, route)\n                    .setValue(this._const.name, attr)\n                    .setValue(this._const.value, t1.attributes[attr])\n                )\n            } else {\n                attr2.splice(pos, 1)\n                if (t1.attributes[attr] !== t2.attributes[attr]) {\n                    diffs.push(new Diff()\n                        .setValue(this._const.action, this._const.modifyAttribute)\n                        .setValue(this._const.route, route)\n                        .setValue(this._const.name, attr)\n                        .setValue(this._const.oldValue, t1.attributes[attr])\n                        .setValue(this._const.newValue, t2.attributes[attr])\n                    )\n                }\n            }\n        }\n\n        attrLength = attr2.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr2[i]\n            diffs.push(new Diff()\n                .setValue(this._const.action, this._const.addAttribute)\n                .setValue(this._const.route, route)\n                .setValue(this._const.name, attr)\n                .setValue(this._const.value, t2.attributes[attr])\n            )\n        }\n\n        return diffs\n    }\n\n    nodeToObj(aNode) {\n        const objNode = {}\n        const dobj = this\n        let nodeArray\n        let childNode\n        let length\n        let attribute\n        let i\n        objNode.nodeName = aNode.nodeName\n        if (objNode.nodeName === '#text' || objNode.nodeName === '#comment') {\n            objNode.data = aNode.data\n        } else {\n            if (aNode.attributes && aNode.attributes.length > 0) {\n                objNode.attributes = {}\n                nodeArray = Array.prototype.slice.call(aNode.attributes)\n                length = nodeArray.length\n                for (i = 0; i < length; i++) {\n                    attribute = nodeArray[i]\n                    objNode.attributes[attribute.name] = attribute.value\n                }\n            }\n            if (objNode.nodeName === 'TEXTAREA') {\n                objNode.value = aNode.value\n            } else if (aNode.childNodes && aNode.childNodes.length > 0) {\n                objNode.childNodes = []\n                nodeArray = Array.prototype.slice.call(aNode.childNodes)\n                length = nodeArray.length\n                for (i = 0; i < length; i++) {\n                    childNode = nodeArray[i]\n                    objNode.childNodes.push(dobj.nodeToObj(childNode))\n                }\n            }\n            if (this.valueDiffing) {\n                if (aNode.checked !== undefined && aNode.type && ['radio', 'checkbox'].includes(aNode.type.toLowerCase())) {\n                    objNode.checked = aNode.checked\n                } else if (aNode.value !== undefined) {\n                    objNode.value = aNode.value\n                }\n                if (aNode.selected !== undefined) {\n                    objNode.selected = aNode.selected\n                }\n            }\n        }\n        return objNode\n    }\n\n    objToNode(objNode, insideSvg) {\n        let node\n        const dobj = this\n        let attribute\n        let attributeArray\n        let childNode\n        let childNodeArray\n        let length\n        let i\n        if (objNode.nodeName === '#text') {\n            node = document.createTextNode(objNode.data)\n\n        } else if (objNode.nodeName === '#comment') {\n            node = document.createComment(objNode.data)\n        } else {\n            if (objNode.nodeName === 'svg' || insideSvg) {\n                node = document.createElementNS('http://www.w3.org/2000/svg', objNode.nodeName)\n                insideSvg = true\n            } else {\n                node = document.createElement(objNode.nodeName)\n            }\n            if (objNode.attributes) {\n                attributeArray = Object.keys(objNode.attributes)\n                length = attributeArray.length\n                for (i = 0; i < length; i++) {\n                    attribute = attributeArray[i]\n                    node.setAttribute(attribute, objNode.attributes[attribute])\n                }\n            }\n            if (objNode.childNodes) {\n                childNodeArray = objNode.childNodes\n                length = childNodeArray.length\n                for (i = 0; i < length; i++) {\n                    childNode = childNodeArray[i]\n                    node.appendChild(dobj.objToNode(childNode, insideSvg))\n                }\n            }\n            if (this.valueDiffing) {\n                if (objNode.value) {\n                    node.value = objNode.value\n                }\n                if (objNode.checked) {\n                    node.checked = objNode.checked\n                }\n                if (objNode.selected) {\n                    node.selected = objNode.selected\n                }\n            }\n        }\n        return node\n    }\n\n    findInnerDiff(t1, t2, route) {\n\n        //var subtrees = (t1.childNodes && t2.childNodes) ?  markSubTrees(t1, t2) : [],\n        const subtrees = t1.subsets && t1.subsetsAge-- ? t1.subsets : (t1.childNodes && t2.childNodes) ? markSubTrees(t1, t2) : []\n\n        const t1ChildNodes = t1.childNodes ? t1.childNodes : []\n        const t2ChildNodes = t2.childNodes ? t2.childNodes : []\n        let childNodesLengthDifference\n        let diffs = []\n        let index = 0\n\n        if (subtrees.length > 0) {\n            /* One or more groups have been identified among the childnodes of t1\n             * and t2.\n             */\n            diffs = this.attemptGroupRelocation(t1, t2, subtrees, route)\n            if (diffs.length > 0) {\n                return diffs\n            }\n        }\n\n        /* 0 or 1 groups of similar child nodes have been found\n         * for t1 and t2. 1 If there is 1, it could be a sign that the\n         * contents are the same. When the number of groups is below 2,\n         * t1 and t2 are made to have the same length and each of the\n         * pairs of child nodes are diffed.\n         */\n\n        const last = Math.max(t1ChildNodes.length, t2ChildNodes.length)\n        if (t1ChildNodes.length !== t2ChildNodes.length) {\n            childNodesLengthDifference = true\n        }\n\n        for (let i = 0; i < last; i += 1) {\n            const e1 = t1ChildNodes[i]\n            const e2 = t2ChildNodes[i]\n\n            if (childNodesLengthDifference) {\n                /* t1 and t2 have different amounts of childNodes. Add\n                 * and remove as necessary to obtain the same length */\n                if (e1 && !e2) {\n                    if (e1.nodeName === '#text') {\n                        diffs.push(new Diff()\n                            .setValue(this._const.action, this._const.removeTextElement)\n                            .setValue(this._const.route, route.concat(index))\n                            .setValue(this._const.value, e1.data)\n                        )\n                        index -= 1\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(this._const.action, this._const.removeElement)\n                            .setValue(this._const.route, route.concat(index))\n                            .setValue(this._const.element, cloneObj(e1))\n                        )\n                        index -= 1\n                    }\n\n                } else if (e2 && !e1) {\n                    if (e2.nodeName === '#text') {\n                        diffs.push(new Diff()\n                            .setValue(this._const.action, this._const.addTextElement)\n                            .setValue(this._const.route, route.concat(index))\n                            .setValue(this._const.value, e2.data)\n                        )\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(this._const.action, this._const.addElement)\n                            .setValue(this._const.route, route.concat(index))\n                            .setValue(this._const.element, cloneObj(e2))\n                        )\n                    }\n                }\n            }\n            /* We are now guaranteed that childNodes e1 and e2 exist,\n             * and that they can be diffed.\n             */\n            /* Diffs in child nodes should not affect the parent node,\n             * so we let these diffs be submitted together with other\n             * diffs.\n             */\n\n            if (e1 && e2) {\n                diffs = diffs.concat(this.findNextDiff(e1, e2, route.concat(index)))\n            }\n\n            index += 1\n\n        }\n        t1.innerDone = true\n        return diffs\n    }\n\n    attemptGroupRelocation(t1, t2, subtrees, route) {\n        /* Either t1.childNodes and t2.childNodes have the same length, or\n         * there are at least two groups of similar elements can be found.\n         * attempts are made at equalizing t1 with t2. First all initial\n         * elements with no group affiliation (gaps=true) are removed (if\n         * only in t1) or added (if only in t2). Then the creation of a group\n         * relocation diff is attempted.\n         */\n        const gapInformation = getGapInformation(t1, t2, subtrees)\n        const gaps1 = gapInformation.gaps1\n        const gaps2 = gapInformation.gaps2\n        let shortest = Math.min(gaps1.length, gaps2.length)\n        let destinationDifferent\n        let toGroup\n        let group\n        let node\n        let similarNode\n        let testI\n        const diffs = []\n\n\n        for (let index2 = 0, index1 = 0; index2 < shortest; index1 += 1, index2 += 1) {\n            if (gaps1[index2] === true) {\n                node = t1.childNodes[index1]\n                if (node.nodeName === '#text') {\n                    if (t2.childNodes[index2].nodeName === '#text' && node.data !== t2.childNodes[index2].data) {\n                        testI = index1\n                        while (t1.childNodes.length > testI + 1 && t1.childNodes[testI + 1].nodeName === '#text') {\n                            testI += 1\n                            if (t2.childNodes[index2].data === t1.childNodes[testI].data) {\n                                similarNode = true\n                                break\n                            }\n                        }\n                        if (!similarNode) {\n                            diffs.push(new Diff()\n                                .setValue(this._const.action, this._const.modifyTextElement)\n                                .setValue(this._const.route, route.concat(index2))\n                                .setValue(this._const.oldValue, node.data)\n                                .setValue(this._const.newValue, t2.childNodes[index2].data)\n                            )\n                            return diffs\n                        }\n                    }\n                    diffs.push(new Diff()\n                        .setValue(this._const.action, this._const.removeTextElement)\n                        .setValue(this._const.route, route.concat(index2))\n                        .setValue(this._const.value, node.data)\n                    )\n                    gaps1.splice(index2, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index2 -= 1\n                } else {\n                    diffs.push(new Diff()\n                        .setValue(this._const.action, this._const.removeElement)\n                        .setValue(this._const.route, route.concat(index2))\n                        .setValue(this._const.element, cloneObj(node))\n                    )\n                    gaps1.splice(index2, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index2 -= 1\n                }\n\n            } else if (gaps2[index2] === true) {\n                node = t2.childNodes[index2]\n                if (node.nodeName === '#text') {\n                    diffs.push(new Diff()\n                        .setValue(this._const.action, this._const.addTextElement)\n                        .setValue(this._const.route, route.concat(index2))\n                        .setValue(this._const.value, node.data)\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                } else {\n                    diffs.push(new Diff()\n                        .setValue(this._const.action, this._const.addElement)\n                        .setValue(this._const.route, route.concat(index2))\n                        .setValue(this._const.element, cloneObj(node))\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                }\n\n            } else if (gaps1[index2] !== gaps2[index2]) {\n                if (diffs.length > 0) {\n                    return diffs\n                }\n                // group relocation\n                group = subtrees[gaps1[index2]]\n                toGroup = Math.min(group.newValue, (t1.childNodes.length - group.length))\n                if (toGroup !== group.oldValue) {\n                    // Check whether destination nodes are different than originating ones.\n                    destinationDifferent = false\n                    for (let j = 0; j < group.length; j += 1) {\n                        if (!roughlyEqual(t1.childNodes[toGroup + j], t1.childNodes[group.oldValue + j], [], false, true)) {\n                            destinationDifferent = true\n                        }\n                    }\n                    if (destinationDifferent) {\n                        return [new Diff()\n                            .setValue(this._const.action, this._const.relocateGroup)\n                            .setValue('groupLength', group.length)\n                            .setValue(this._const.from, group.oldValue)\n                            .setValue(this._const.to, toGroup)\n                            .setValue(this._const.route, route)\n                        ]\n                    }\n                }\n            }\n        }\n        return diffs\n    }\n\n    findValueDiff(t1, t2, route) {\n        // Differences of value. Only useful if the value/selection/checked value\n        // differs from what is represented in the DOM. For example in the case\n        // of filled out forms, etc.\n        const diffs = []\n\n        if (t1.selected !== t2.selected) {\n            diffs.push(new Diff()\n                .setValue(this._const.action, this._const.modifySelected)\n                .setValue(this._const.oldValue, t1.selected)\n                .setValue(this._const.newValue, t2.selected)\n                .setValue(this._const.route, route)\n            )\n        }\n\n        if ((t1.value || t2.value) && t1.value !== t2.value && t1.nodeName !== 'OPTION') {\n            diffs.push(new Diff()\n                .setValue(this._const.action, this._const.modifyValue)\n                .setValue(this._const.oldValue, t1.value || \"\")\n                .setValue(this._const.newValue, t2.value || \"\")\n                .setValue(this._const.route, route)\n            )\n        }\n        if (t1.checked !== t2.checked) {\n            diffs.push(new Diff()\n                .setValue(this._const.action, this._const.modifyChecked)\n                .setValue(this._const.oldValue, t1.checked)\n                .setValue(this._const.newValue, t2.checked)\n                .setValue(this._const.route, route)\n            )\n        }\n\n        return diffs\n    }\n\n    // ===== Apply a virtual diff =====\n\n    applyVirtual(tree, diffs) {\n        diffs.forEach(diff => {\n            this.applyVirtualDiff(tree, diff)\n        })\n        return true\n    }\n\n    getFromVirtualRoute(tree, route) {\n        let node = tree\n        let parentNode\n        let nodeIndex\n\n        route = route.slice()\n        while (route.length > 0) {\n            if (!node.childNodes) {\n                return false\n            }\n            nodeIndex = route.splice(0, 1)[0]\n            parentNode = node\n            node = node.childNodes[nodeIndex]\n        }\n        return {\n            node,\n            parentNode,\n            nodeIndex\n        }\n    }\n\n    applyVirtualDiff(tree, diff) {\n        const routeInfo = this.getFromVirtualRoute(tree, diff[this._const.route])\n        let node = routeInfo.node\n        const parentNode = routeInfo.parentNode\n        const nodeIndex = routeInfo.nodeIndex\n        const newSubsets = []\n\n        // pre-diff hook\n        const info = {\n            diff,\n            node\n        }\n\n        if (this.preVirtualDiffApply(info)) {\n            return true\n        }\n\n        let newNode\n        let nodeArray\n        let route\n        let c\n        switch (diff[this._const.action]) {\n            case this._const.addAttribute:\n                if (!node.attributes) {\n                    node.attributes = {}\n                }\n\n                node.attributes[diff[this._const.name]] = diff[this._const.value]\n\n                if (diff[this._const.name] === 'checked') {\n                    node.checked = true\n                } else if (diff[this._const.name] === 'selected') {\n                    node.selected = true\n                } else if (node.nodeName === 'INPUT' && diff[this._const.name] === 'value') {\n                    node.value = diff[this._const.value]\n                }\n\n                break\n            case this._const.modifyAttribute:\n                node.attributes[diff[this._const.name]] = diff[this._const.newValue]\n                break\n            case this._const.removeAttribute:\n\n                delete node.attributes[diff[this._const.name]]\n\n                if (Object.keys(node.attributes).length === 0) {\n                    delete node.attributes\n                }\n\n                if (diff[this._const.name] === 'checked') {\n                    node.checked = false\n                } else if (diff[this._const.name] === 'selected') {\n                    delete node.selected\n                } else if (node.nodeName === 'INPUT' && diff[this._const.name] === 'value') {\n                    delete node.value\n                }\n\n                break\n            case this._const.modifyTextElement:\n                node.data = diff[this._const.newValue]\n                break\n            case this._const.modifyValue:\n                node.value = diff[this._const.newValue]\n                break\n            case this._const.modifyComment:\n                node.data = diff[this._const.newValue]\n                break\n            case this._const.modifyChecked:\n                node.checked = diff[this._const.newValue]\n                break\n            case this._const.modifySelected:\n                node.selected = diff[this._const.newValue]\n                break\n            case this._const.replaceElement:\n                newNode = cloneObj(diff[this._const.newValue])\n                newNode.outerDone = true\n                newNode.innerDone = true\n                newNode.valueDone = true\n                parentNode.childNodes[nodeIndex] = newNode\n                break\n            case this._const.relocateGroup:\n                nodeArray = node.childNodes.splice(diff[this._const.from], diff.groupLength).reverse()\n                nodeArray.forEach(movedNode => node.childNodes.splice(diff[this._const.to], 0, movedNode))\n                if (node.subsets) {\n                    node.subsets.forEach(map => {\n                        if (diff[this._const.from] < diff[this._const.to] && map.oldValue <= diff[this._const.to] && map.oldValue > diff[this._const.from]) {\n                            map.oldValue -= diff.groupLength\n                            const splitLength = map.oldValue + map.length - diff[this._const.to]\n                            if (splitLength > 0) {\n                                // new insertion splits map.\n                                newSubsets.push({\n                                    oldValue: diff[this._const.to] + diff.groupLength,\n                                    newValue: map.newValue + map.length - splitLength,\n                                    length: splitLength\n                                })\n                                map.length -= splitLength\n                            }\n                        } else if (diff[this._const.from] > diff[this._const.to] && map.oldValue > diff[this._const.to] && map.oldValue < diff[this._const.from]) {\n                            map.oldValue += diff.groupLength\n                            const splitLength = map.oldValue + map.length - diff[this._const.to]\n                            if (splitLength > 0) {\n                                // new insertion splits map.\n                                newSubsets.push({\n                                    oldValue: diff[this._const.to] + diff.groupLength,\n                                    newValue: map.newValue + map.length - splitLength,\n                                    length: splitLength\n                                })\n                                map.length -= splitLength\n                            }\n                        } else if (map.oldValue === diff[this._const.from]) {\n                            map.oldValue = diff[this._const.to]\n                        }\n                    })\n                }\n\n                break\n            case this._const.removeElement:\n                parentNode.childNodes.splice(nodeIndex, 1)\n                if (parentNode.subsets) {\n                    parentNode.subsets.forEach(map => {\n                        if (map.oldValue > nodeIndex) {\n                            map.oldValue -= 1\n                        } else if (map.oldValue === nodeIndex) {\n                            map.delete = true\n                        } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                            if (map.oldValue + map.length - 1 === nodeIndex) {\n                                map.length--\n                            } else {\n                                newSubsets.push({\n                                    newValue: map.newValue + nodeIndex - map.oldValue,\n                                    oldValue: nodeIndex,\n                                    length: map.length - nodeIndex + map.oldValue - 1\n                                })\n                                map.length = nodeIndex - map.oldValue\n                            }\n                        }\n                    })\n                }\n                node = parentNode\n                break\n            case this._const.addElement:\n                route = diff[this._const.route].slice()\n                c = route.splice(route.length - 1, 1)[0]\n                node = this.getFromVirtualRoute(tree, route).node\n                newNode = cloneObj(diff[this._const.element])\n                newNode.outerDone = true\n                newNode.innerDone = true\n                newNode.valueDone = true\n\n                if (!node.childNodes) {\n                    node.childNodes = []\n                }\n\n                if (c >= node.childNodes.length) {\n                    node.childNodes.push(newNode)\n                } else {\n                    node.childNodes.splice(c, 0, newNode)\n                }\n                if (node.subsets) {\n                    node.subsets.forEach(map => {\n                        if (map.oldValue >= c) {\n                            map.oldValue += 1\n                        } else if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                            const splitLength = map.oldValue + map.length - c\n                            newSubsets.push({\n                                newValue: map.newValue + map.length - splitLength,\n                                oldValue: c + 1,\n                                length: splitLength\n                            })\n                            map.length -= splitLength\n                        }\n                    })\n                }\n                break\n            case this._const.removeTextElement:\n                parentNode.childNodes.splice(nodeIndex, 1)\n                if (parentNode.nodeName === 'TEXTAREA') {\n                    delete parentNode.value\n                }\n                if (parentNode.subsets) {\n                    parentNode.subsets.forEach(map => {\n                        if (map.oldValue > nodeIndex) {\n                            map.oldValue -= 1\n                        } else if (map.oldValue === nodeIndex) {\n                            map.delete = true\n                        } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                            if (map.oldValue + map.length - 1 === nodeIndex) {\n                                map.length--\n                            } else {\n                                newSubsets.push({\n                                    newValue: map.newValue + nodeIndex - map.oldValue,\n                                    oldValue: nodeIndex,\n                                    length: map.length - nodeIndex + map.oldValue - 1\n                                })\n                                map.length = nodeIndex - map.oldValue\n                            }\n                        }\n                    })\n                }\n                node = parentNode\n                break\n            case this._const.addTextElement:\n                route = diff[this._const.route].slice()\n                c = route.splice(route.length - 1, 1)[0]\n                newNode = {}\n                newNode.nodeName = '#text'\n                newNode.data = diff[this._const.value]\n                node = this.getFromVirtualRoute(tree, route).node\n                if (!node.childNodes) {\n                    node.childNodes = []\n                }\n\n                if (c >= node.childNodes.length) {\n                    node.childNodes.push(newNode)\n                } else {\n                    node.childNodes.splice(c, 0, newNode)\n                }\n                if (node.nodeName === 'TEXTAREA') {\n                    node.value = diff[this._const.newValue]\n                }\n                if (node.subsets) {\n                    node.subsets.forEach(map => {\n                        if (map.oldValue >= c) {\n                            map.oldValue += 1\n                        }\n                        if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                            const splitLength = map.oldValue + map.length - c\n                            newSubsets.push({\n                                newValue: map.newValue + map.length - splitLength,\n                                oldValue: c + 1,\n                                length: splitLength\n                            })\n                            map.length -= splitLength\n                        }\n                    })\n                }\n                break\n            default:\n                console.log('unknown action')\n        }\n\n        if (node.subsets) {\n            node.subsets = node.subsets.filter(map => !map.delete && map.oldValue !== map.newValue)\n            if (newSubsets.length) {\n                node.subsets = node.subsets.concat(newSubsets)\n            }\n        }\n\n        // capture newNode for the callback\n        info.newNode = newNode\n        this.postVirtualDiffApply(info)\n\n        return\n    }\n\n    // ===== Apply a diff =====\n\n    apply(tree, diffs) {\n        return diffs.every(diff => this.applyDiff(tree, diff))\n    }\n\n\n    getFromRoute(node, route) {\n        route = route.slice()\n        while (route.length > 0) {\n            if (!node.childNodes) {\n                return false\n            }\n            const c = route.splice(0, 1)[0]\n            node = node.childNodes[c]\n        }\n        return node\n    }\n\n    applyDiff(tree, diff) {\n        let node = this.getFromRoute(tree, diff[this._const.route])\n        let newNode\n        let reference\n        let route\n        let nodeArray\n        let c\n\n        // pre-diff hook\n        const info = {\n            diff,\n            node\n        }\n\n        if (this.preDiffApply(info)) {\n            return true\n        }\n\n        switch (diff[this._const.action]) {\n            case this._const.addAttribute:\n                if (!node || !node.setAttribute) {\n                    return false\n                }\n                node.setAttribute(diff[this._const.name], diff[this._const.value])\n                break\n            case this._const.modifyAttribute:\n                if (!node || !node.setAttribute) {\n                    return false\n                }\n                node.setAttribute(diff[this._const.name], diff[this._const.newValue])\n                if (node.nodeName === 'INPUT' && diff[this._const.name] === 'value') {\n                    node.value = diff[this._const.oldValue]\n                }\n                break\n            case this._const.removeAttribute:\n                if (!node || !node.removeAttribute) {\n                    return false\n                }\n                node.removeAttribute(diff[this._const.name])\n                break\n            case this._const.modifyTextElement:\n                if (!node || node.nodeType !== 3) {\n                    return false\n                }\n                this.textDiff(node, node.data, diff[this._const.oldValue], diff[this._const.newValue])\n                break\n            case this._const.modifyValue:\n                if (!node || typeof node.value === 'undefined') {\n                    return false\n                }\n                node.value = diff[this._const.newValue]\n                break\n            case this._const.modifyComment:\n                if (!node || typeof node.data === 'undefined') {\n                    return false\n                }\n                this.textDiff(node, node.data, diff[this._const.oldValue], diff[this._const.newValue])\n                break\n            case this._const.modifyChecked:\n                if (!node || typeof node.checked === 'undefined') {\n                    return false\n                }\n                node.checked = diff[this._const.newValue]\n                break\n            case this._const.modifySelected:\n                if (!node || typeof node.selected === 'undefined') {\n                    return false\n                }\n                node.selected = diff[this._const.newValue]\n                break\n            case this._const.replaceElement:\n                node.parentNode.replaceChild(this.objToNode(diff[this._const.newValue], node.namespaceURI === 'http://www.w3.org/2000/svg'), node)\n                break\n            case this._const.relocateGroup:\n                nodeArray = Array(...new Array(diff.groupLength)).map(() => node.removeChild(node.childNodes[diff[this._const.from]]))\n                nodeArray.forEach((childNode, index) => {\n                    if (index === 0) {\n                        reference = node.childNodes[diff[this._const.to]]\n                    }\n                    node.insertBefore(childNode, reference || null)\n                })\n                break\n            case this._const.removeElement:\n                node.parentNode.removeChild(node)\n                break\n            case this._const.addElement:\n                route = diff[this._const.route].slice()\n                c = route.splice(route.length - 1, 1)[0]\n                node = this.getFromRoute(tree, route)\n                node.insertBefore(this.objToNode(diff[this._const.element], node.namespaceURI === 'http://www.w3.org/2000/svg'), node.childNodes[c] || null)\n                break\n            case this._const.removeTextElement:\n                if (!node || node.nodeType !== 3) {\n                    return false\n                }\n                node.parentNode.removeChild(node)\n                break\n            case this._const.addTextElement:\n                route = diff[this._const.route].slice()\n                c = route.splice(route.length - 1, 1)[0]\n                newNode = document.createTextNode(diff[this._const.value])\n                node = this.getFromRoute(tree, route)\n                if (!node || !node.childNodes) {\n                    return false\n                }\n                node.insertBefore(newNode, node.childNodes[c] || null)\n                break\n            default:\n                console.log('unknown action')\n        }\n\n        // if a new node was created, we might be interested in it\n        // post diff hook\n        info.newNode = newNode\n        this.postDiffApply(info)\n\n        return true\n    }\n\n    // ===== Undo a diff =====\n\n    undo(tree, diffs) {\n        if (!diffs.length) {\n            diffs = [diffs]\n        }\n        diffs = diffs.slice()\n        diffs.reverse()\n        diffs.forEach(diff => {\n            this.undoDiff(tree, diff)\n        })\n    }\n\n    undoDiff(tree, diff) {\n\n        switch (diff[this._const.action]) {\n            case this._const.addAttribute:\n                diff[this._const.action] = this._const.removeAttribute\n                this.applyDiff(tree, diff)\n                break\n            case this._const.modifyAttribute:\n                swap(diff, this._const.oldValue, this._const.newValue)\n                this.applyDiff(tree, diff)\n                break\n            case this._const.removeAttribute:\n                diff[this._const.action] = this._const.addAttribute\n                this.applyDiff(tree, diff)\n                break\n            case this._const.modifyTextElement:\n                swap(diff, this._const.oldValue, this._const.newValue)\n                this.applyDiff(tree, diff)\n                break\n            case this._const.modifyValue:\n                swap(diff, this._const.oldValue, this._const.newValue)\n                this.applyDiff(tree, diff)\n                break\n            case this._const.modifyComment:\n                swap(diff, this._const.oldValue, this._const.newValue)\n                this.applyDiff(tree, diff)\n                break\n            case this._const.modifyChecked:\n                swap(diff, this._const.oldValue, this._const.newValue)\n                this.applyDiff(tree, diff)\n                break\n            case this._const.modifySelected:\n                swap(diff, this._const.oldValue, this._const.newValue)\n                this.applyDiff(tree, diff)\n                break\n            case this._const.replaceElement:\n                swap(diff, this._const.oldValue, this._const.newValue)\n                this.applyDiff(tree, diff)\n                break\n            case this._const.relocateGroup:\n                swap(diff, this._const.from, this._const.to)\n                this.applyDiff(tree, diff)\n                break\n            case this._const.removeElement:\n                diff[this._const.action] = this._const.addElement\n                this.applyDiff(tree, diff)\n                break\n            case this._const.addElement:\n                diff[this._const.action] = this._const.removeElement\n                this.applyDiff(tree, diff)\n                break\n            case this._const.removeTextElement:\n                diff[this._const.action] = this._const.addTextElement\n                this.applyDiff(tree, diff)\n                break\n            case this._const.addTextElement:\n                diff[this._const.action] = this._const.removeTextElement\n                this.applyDiff(tree, diff)\n                break\n            default:\n                console.log('unknown action')\n        }\n\n    }\n}\n","export interface IDiff {\n  index: number;\n  oldValue: any;\n  newValue: any;\n  type: diffType;\n}\n\n// edit/add/delete\ntype diffType = \"E\" | \"A\" | \"D\";\n\n// no more function\nfunction filterOutFn(input: object): object {\n  return Object.entries(input).reduce((last, [key, value]) => {\n    if (typeof value === \"function\") {\n      return last;\n    }\n    return {\n      ...last,\n      [key]: value\n    };\n  }, {});\n}\n\n// sort object\n// ! for edge cases\nfunction sort(input: { [index: string]: any }): {} {\n  return Object.keys(input)\n    .sort()\n    .reduce((last, key) => {\n      return {\n        ...last,\n        [key]: input[key]\n      };\n    }, {});\n}\n\n// is object\nfunction isObj(input: any): boolean {\n  return Object.prototype.toString.call(input) === \"[object Object]\";\n}\n\n// safe stringify\nfunction stringify(input: any): string {\n  if (isObj(input)) {\n    return JSON.stringify(sort(filterOutFn(input)));\n  }\n  return JSON.stringify(input);\n}\n\n// find same element\nfunction findSame(left: any[], right: any[]): Array<[number, number]> {\n  return left.reduce((last: number[], item, i) => {\n    const itemStr = stringify(item);\n    const index: number = right.findIndex(\n      rightItem => stringify(rightItem) === itemStr\n    );\n    if (index > -1) {\n      return [...last, [i, index]];\n    }\n  }, []) as Array<[number, number]>;\n}\n\n// simple diff for array\nexport default function compareArray(\n  left: any[],\n  right: any[],\n  start: number = 0\n): IDiff[] {\n  const leftLen: number = left.length;\n  const rightLen: number = right.length;\n  if (leftLen === rightLen) {\n    return left.reduce((last: IDiff[], item, i) => {\n      const rightItem: any = right[i];\n      if (typeof item === \"function\" && typeof rightItem === \"function\") {\n        return last;\n      }\n      const leftStr: string = stringify(item);\n      const rightStr: string = stringify(rightItem);\n      if (leftStr !== rightStr) {\n        return [\n          ...last,\n          {\n            index: i + start,\n            oldValue: item,\n            newValue: rightItem,\n            type: \"E\"\n          }\n        ];\n      }\n      return last;\n    }, []);\n  } else if (leftLen > rightLen) {\n    // delete\n    if (rightLen === 0) {\n      return left.map((item, i) => {\n        return {\n          index: i + start,\n          oldValue: item,\n          newValue: undefined,\n          type: \"D\"\n        };\n      }) as IDiff[];\n    } else {\n      const samePair: Array<[number, number]> = findSame(left, right);\n      // just delete?\n      const isJustDel: boolean = samePair.length === rightLen;\n      // update + delete\n      if (!isJustDel) {\n        return compareArray(left.slice(0, rightLen), right).concat(\n          compareArray(left.slice(rightLen), [], rightLen)\n        );\n      }\n      return left.reduce((last, item, i) => {\n        const hasSame: boolean = samePair.some(\n          ([leftIndex]) => leftIndex === i\n        );\n        if (hasSame) {\n          return last;\n        }\n        return {\n          index: i + start,\n          oldValue: item,\n          newValue: undefined,\n          type: \"D\"\n        };\n      }, []);\n    }\n  } else {\n    // add\n    if (leftLen === 0) {\n      return right.map((item, i) => {\n        return {\n          index: i + start,\n          oldValue: undefined,\n          newValue: item,\n          type: \"A\"\n        };\n      }) as IDiff[];\n    } else {\n      const samePair: Array<[number, number]> = findSame(left, right);\n      // just add?\n      const isJustAdd: boolean = samePair.length === leftLen;\n      if (!isJustAdd) {\n        return compareArray(left, right.slice(0, leftLen)).concat(\n          compareArray([], right.slice(leftLen), leftLen)\n        );\n      }\n      return right.reduce((last, item, i) => {\n        const hasSame: boolean = samePair.some(\n          ([_, rightIndex]) => rightIndex === i\n        );\n        if (hasSame) {\n          return last;\n        }\n        return [\n          ...last,\n          {\n            index: i + start,\n            oldValue: undefined,\n            newValue: item,\n            type: \"A\"\n          }\n        ];\n      }, []) as IDiff[];\n    }\n  }\n}\n","const regProducer = (): RegExp =>\n  /^<([a-z]+)([^>]*?)(\\/?>|(>([\\s\\S]*?)<\\/\\1>))$/i;\nexport default function matchEl(\n  input: string\n): {\n  tag: string;\n  attributes: string;\n  innerHTML: string;\n} | null {\n  const result = input.match(regProducer());\n  if (!result) {\n    return null;\n  }\n  return {\n    tag: result[1],\n    attributes: result[2] || \"\",\n    innerHTML: result[5] || \"\"\n  };\n}\n","import matchEl from \"./matchEl\";\nexport default function domParser(dom: string): HTMLElement {\n  if (\"jQuery\" in window) {\n    return $(dom)[0];\n  }\n  const match = matchEl(dom.trim());\n  if (!match) {\n    throw new Error(`source: ${dom}; Not a valid element! check render()`);\n  }\n  const el = document.createElement(match.tag);\n  el.innerHTML = match.innerHTML;\n  const { attributes } = match;\n  if (attributes) {\n    const attr: { [index: string]: string } = {};\n    attributes\n      .trim()\n      .replace(/([a-zA-Z]+)=([^'\"]+|(['\"])([^'\"]+)\\3)/g, (_, key, values) => {\n        attr[key] = values.replace(/['\"]/g, \"\");\n        return _;\n      });\n    Object.entries(attr).forEach(([k, v]) => {\n      el.setAttribute(k, v);\n    });\n  }\n  return el;\n}\n","export default function replaceDom(\n  refDom: HTMLElement,\n  newDoms: HTMLElement | HTMLElement[],\n  ...extraDoms: HTMLElement[]\n): void {\n  const newDomsArr: HTMLElement[] = Array.isArray(newDoms)\n    ? [...newDoms, ...extraDoms]\n    : [newDoms, ...extraDoms];\n  if (\"jQuery\" in window) {\n    $(refDom).replaceWith(newDomsArr);\n    return;\n  }\n  const parent: HTMLElement | null = refDom.parentElement;\n  if (!parent) {\n    return;\n  }\n  if (!newDomsArr.length) {\n    throw new Error(\"Need to provide new DOM!\");\n  }\n  let ref: HTMLElement = refDom;\n  for (let i = newDomsArr.length - 1; i >= 0; i--) {\n    const newDom: HTMLElement = newDomsArr[i];\n    parent.insertBefore(newDom, ref);\n    ref = newDom;\n  }\n  parent.removeChild(refDom);\n}\n","export default function selectDom(\n  selector: string,\n  context: HTMLElement | Document = document\n): HTMLElement | null {\n  if (\"jQuery\" in window) {\n    return $(context as HTMLElement).find(selector)[0];\n  } else {\n    return context.querySelector(selector);\n  }\n}\n","const filterObject = <T extends object = {}>(\n  predict: <K extends keyof T>(pair: [K, T[K]], source: T) => boolean\n) => (obj: T): Partial<T> => {\n  return Object.entries(obj).reduce((last: Partial<T>, pair) => {\n    const [k, v] = pair as [keyof T, T[keyof T]];\n    if (predict([k, v], obj)) {\n      return Object.assign(last, { [k]: v });\n    }\n    return last;\n  }, {});\n};\n\nexport default filterObject;\n","import Component, { IComponentsRawHash } from \"../core/Component\";\n\ninterface IStore {\n  activeComponent: Component<any, any> | null;\n  componentArray: Component[];\n  stateList: any[];\n  effectList: any[];\n  components: () => IComponentsRawHash;\n  makeState: () => { [index: number]: any };\n  clear: () => void;\n}\n\nexport const store: IStore = {\n  activeComponent: null,\n  componentArray: [],\n  stateList: [],\n  effectList: [],\n  components: () => ({}),\n  makeState() {\n    return store.stateList.reduce((last, item: any, index: number) => {\n      return {\n        ...last,\n        [index]: item\n      };\n    }, {});\n  },\n  clear() {\n    store.stateList = [];\n    store.effectList = [];\n    store.components = () => ({});\n  }\n};\n","import { DiffDOM } from \"diff-dom\";\nimport compareArray, { IDiff } from \"../util/compareArray\";\nimport domParser from \"../util/domParser\";\nimport replaceDom from \"../util/replaceDom\";\nimport insertBefore from \"../util/insertBefore\";\nimport insertAfter from \"../util/insertAfter\";\nimport removeDom from \"../util/removeDom\";\nimport filterObj from \"../util/filterObject\";\nimport selectDom from \"../util/selectDom\";\nimport { store } from \"../hooks/store\";\nconst config = {\n  logDiff: false\n};\nconst dd = new DiffDOM({\n  preVirtualDiffApply(info: any) {\n    if (!config.logDiff) {\n      return;\n    }\n    console.log(info);\n  },\n  preDiffApply(info: { diff: { action: string } }) {\n    if (info.diff.action === \"modifyValue\") {\n      return true;\n    }\n  }\n});\n\n// filter out Component\nconst filterOutInstance = filterObj(([_, v]) => {\n  const isInstance: boolean = (v as any) instanceof Component;\n  return !isInstance;\n});\n\ninterface IObj {\n  [index: string]: any;\n}\n// props type\ntype Prop<P> = (() => P) | P;\ninterface IProp<P> {\n  props?: Prop<P>;\n}\n\ntype FnComponent = () => string;\n\n// For components method, accept both Base and FnComponent\nexport interface IComponentsRawHash {\n  [name: string]: Component | FnComponent | Array<Component | FnComponent>;\n}\n\n// convert all components to Base | Base[]\ninterface IComponentsHash {\n  [name: string]: Component | Component[];\n}\n\ninterface IComponentOption<P> extends IProp<P> {\n  el?: string;\n  fnComponent?: FnComponent;\n}\n\n// convert functional component to class\nconst convertFnToClass = (component: Component | FnComponent): Component => {\n  if (component instanceof Component) {\n    return component;\n  }\n  return new Component({\n    fnComponent: component\n  }).init();\n};\n\nexport default class Component<P extends IObj = {}, S extends IObj = {}> {\n  public ref!: HTMLElement;\n  public parent: Component<any, any> | null = null;\n  public renderOption!: IComponentOption<P>;\n  public state!: Readonly<S>;\n  public props: P = {} as P;\n  public lastRenderSnapshot: string = \"\";\n  public lastComponentsSnapshot: IComponentsHash = {};\n  public mounted: boolean = false;\n  private preRenderResult: string = \"\";\n  constructor(option: IComponentOption<P> = {}) {\n    // cache option\n    this.renderOption = option;\n    this.initProps(option.props);\n  }\n\n  // constructor -> render -> didMount\n  public init() {\n    // preRender so that components can be registered properly\n    this.preRenderForFunction();\n    // cache result\n    this.lastComponentsSnapshot = this.safeComponents();\n    // update DOM\n    this.update();\n    // cache render\n    this.lastRenderSnapshot = this.render();\n    return this;\n  }\n\n  public components(): IComponentsRawHash {\n    return {};\n  }\n\n  public didMount(): void {\n    return;\n  }\n\n  public didUpdate(): void {\n    return;\n  }\n\n  public willUnMount(): void {\n    return;\n  }\n\n  public shouldUpdate(): boolean | void {\n    return;\n  }\n\n  public render(props = this.props, state = this.state): string {\n    // handle functional component\n    if (this.renderOption.fnComponent) {\n      // empty hooks\n      store.clear();\n      // set active\n      store.activeComponent = this;\n      // use preRender result for first time rendering\n      return !this.mounted\n        ? this.preRenderResult\n        : this.renderOption.fnComponent();\n    }\n    return \"<div></div>\";\n  }\n\n  // update state\n  public setState<K extends keyof S>(\n    state: Pick<S, K> | ((prevState: S) => S)\n  ) {\n    let stateToIterate!: Pick<S, K> | S;\n    if (typeof state === \"function\") {\n      stateToIterate = state(Object.assign({}, this.state));\n    } else {\n      stateToIterate = state;\n    }\n    if (!stateToIterate) {\n      throw new Error(\"invalid state!\");\n    }\n    // skip extra reduce\n    if (typeof state === \"function\") {\n      this.state = stateToIterate as S;\n      return this.update();\n    }\n    const { newState, hasChanged } = Object.entries(stateToIterate).reduce(\n      (\n        last: {\n          newState: Pick<S, K>;\n          hasChanged: boolean;\n        },\n        [key, value]: [string, any]\n      ) => {\n        const hasKey = key in this.state;\n        // discard if didn't exist\n        if (!hasKey) {\n          return last;\n        }\n        const changed: boolean = value !== this.state[key];\n        return {\n          newState: Object.assign(last.newState, { [key]: value }),\n          hasChanged: last.hasChanged || changed\n        };\n      },\n      {\n        hasChanged: false,\n        newState: this.state\n      }\n    );\n    if (hasChanged) {\n      this.state = newState as S;\n      this.update();\n    }\n  }\n\n  // props\n  private propsFunc: () => P = () => ({} as P);\n\n  private updateSelf() {\n    if (!this.shouldUpdateSelf()) {\n      return;\n    }\n    const { el } = this.renderOption;\n    const lastRef: HTMLElement = this.ref;\n    const html: string = this.render();\n    // update render cache\n    this.lastRenderSnapshot = html;\n    // early exit if no result\n    if (!html || !html.trim()) {\n      return;\n    }\n    const element: HTMLElement = domParser(html);\n    if (!lastRef) {\n      // bind ref\n      this.ref = element;\n    } else {\n      // for functional components\n      // it is crucial that hasChildren is called after render\n      if (this.hasChildren()) {\n        // update children first\n        // todo: better solution\n        this.replaceSlotWithChild(this.lastComponentsSnapshot, element, false);\n      }\n      this.patch(element);\n      return;\n    }\n    // only mount root component here\n    const isRoot: boolean = !!el && typeof el === \"string\";\n    if (!isRoot) {\n      return;\n    }\n    (selectDom(el as string) as HTMLElement).appendChild(this.ref);\n    // mount\n    if (!this.mounted) {\n      this.mount();\n    }\n  }\n\n  // update component\n  private update() {\n    this.props = this.propsFunc();\n    this.updateChildren();\n    this.updateSelf();\n  }\n\n  private updateChildren() {\n    const hash: IComponentsHash = this.safeComponents();\n    // no children, early exit\n    if (!this.hasChildren(hash)) {\n      return;\n    }\n    // get last cache\n    const oldHash: IComponentsHash = this.lastComponentsSnapshot;\n    Object.entries(hash).forEach(([name, component]) => {\n      const oldComponent = oldHash[name];\n      // array\n      if (Array.isArray(component) && Array.isArray(oldComponent)) {\n        // init\n        component.forEach(c => this.initChild(c));\n        const oldLen: number = oldComponent.length;\n        const len: number = component.length;\n        // compare props to decide how to update children\n        const oldProps: object[] = oldComponent\n          .map(c => c.props)\n          .map(filterOutInstance);\n        const newProps: object[] = component\n          .map(c => c.props)\n          .map(filterOutInstance);\n        const arrayDiff = compareArray(oldProps, newProps);\n        // get update/add/delete array\n        const { update, add, del } = arrayDiff.reduce(\n          (last: { update: IDiff[]; del: IDiff[]; add: IDiff[] }, item) => {\n            if (item.type === \"E\") {\n              last.update.push(item);\n            }\n            if (item.type === \"D\") {\n              last.del.push(item);\n            }\n            if (item.type === \"A\") {\n              last.add.push(item);\n            }\n            return last;\n          },\n          {\n            update: [],\n            add: [],\n            del: []\n          }\n        );\n        // update has first class priority\n        update.forEach(item => {\n          const { index } = item;\n          const c: Component = component[index];\n          const oldC: Component = oldComponent[index];\n          oldC.propsFunc = c.propsFunc;\n          oldC.update();\n        });\n        // deal with add\n        if (add.length && add.length === len + oldLen) {\n          // 0 -> n\n          const target: HTMLElement | null = selectDom(name, this.ref);\n          if (target) {\n            replaceDom(target, component.map(c => c.ref));\n          }\n          component.forEach(c => c.mount());\n          this.lastComponentsSnapshot[name] = component;\n        } else {\n          const oldEl: HTMLElement[] = oldComponent.map(c => c.ref);\n          add.forEach((item, i) => {\n            const { index } = item;\n            const newC: Component = component[index];\n            // add to middle\n            if (index < oldLen) {\n              insertBefore(oldEl[index], newC.ref);\n              (this.lastComponentsSnapshot[name] as Component[]).splice(\n                index + i,\n                0,\n                newC\n              );\n            } else {\n              // append\n              const ref: HTMLElement =\n                index === oldLen\n                  ? oldComponent[oldLen - 1].ref\n                  : component[index - 1].ref;\n              insertAfter(ref, newC.ref);\n              (this.lastComponentsSnapshot[name] as Component[])[index] = newC;\n            }\n            // mount\n            newC.mount();\n          });\n        }\n        // n -> 0 ?\n        const isEmpty: boolean = del.length === oldLen;\n        // deal with delete\n        del.forEach((item, i) => {\n          const { index } = item;\n          const oldC: Component = oldComponent[index];\n          (this.lastComponentsSnapshot[name] as Component[]).splice(\n            index - i,\n            1\n          );\n          oldC.willUnMount();\n          if (isEmpty && index === oldLen - 1) {\n            return replaceDom(oldC.ref, domParser(name));\n          }\n          removeDom(oldC.ref);\n        });\n      } else if (!Array.isArray(component) && !Array.isArray(oldComponent)) {\n        // update single component\n        oldComponent.propsFunc = component.propsFunc;\n        oldComponent.update();\n      }\n    });\n  }\n\n  private hasChildren(\n    hash: IComponentsHash = this.lastComponentsSnapshot\n  ): boolean {\n    return Object.keys(hash).length > 0;\n  }\n\n  // handle component in function type\n  private safeComponents(): IComponentsHash {\n    return Object.entries(this.components()).reduce(\n      (last: IComponentsHash, [name, component]) => {\n        if (Array.isArray(component)) {\n          last[name] = component.map(convertFnToClass);\n        } else {\n          last[name] = convertFnToClass(component);\n        }\n        return last;\n      },\n      {}\n    );\n  }\n\n  // assign parent\n  private initChild(child: Component) {\n    child.parent = this;\n  }\n\n  private preRenderForFunction() {\n    if (\n      this.renderOption.fnComponent &&\n      typeof this.renderOption.fnComponent === \"function\"\n    ) {\n      store.clear();\n      // set active\n      store.activeComponent = this;\n      // cache result\n      this.preRenderResult = this.renderOption.fnComponent();\n      // init state\n      this.state = store.makeState() as S;\n      // set life cycle hooks\n      if (store.effectList.length) {\n        const [didMount, willUnMount] = store.effectList.pop();\n        if (typeof didMount === \"function\") {\n          this.didMount = didMount;\n        }\n        if (typeof willUnMount === \"function\") {\n          this.willUnMount = willUnMount;\n        }\n      }\n    }\n  }\n\n  // replace custom element with real element\n  private replaceSlotWithChild(\n    components: IComponentsHash,\n    ref: HTMLElement = this.ref,\n    isRegister: boolean = true\n  ) {\n    // not register phase\n    // using existing outerHTML to replace\n    Object.entries(components).forEach(([name, child]) => {\n      let replaceElement: HTMLElement[] | HTMLElement | null = null;\n      if (Array.isArray(child)) {\n        // only assign if has children\n        if (child.length) {\n          child.forEach(c => this.initChild(c));\n          replaceElement = child.map(c => {\n            return isRegister ? c.ref : domParser(c.ref.outerHTML);\n          });\n        }\n      } else {\n        this.initChild(child);\n        // could be no ref if render returns \"\" or null or undefined\n        if (child.ref) {\n          replaceElement = isRegister\n            ? child.ref\n            : domParser(child.ref.outerHTML);\n        }\n      }\n      // if have elements, then replace\n      // or leave it be\n      if (replaceElement) {\n        const target: HTMLElement | null = selectDom(name, ref);\n        if (target) {\n          replaceDom(target, replaceElement);\n        }\n      }\n      // don't trigger mount if it is not register phase\n      if (!isRegister) {\n        return;\n      }\n      // mount\n      if (Array.isArray(child)) {\n        child.forEach(c => {\n          if (c.ref) {\n            c.mount();\n          }\n        });\n      } else {\n        if (child.ref) {\n          child.mount();\n        }\n      }\n    });\n  }\n\n  private shouldUpdateSelf(): boolean {\n    // override\n    const manualResult: boolean | void = this.shouldUpdate();\n    if (typeof manualResult === \"boolean\") {\n      return manualResult;\n    }\n    const renderResult: string = this.render();\n    return renderResult !== this.lastRenderSnapshot;\n  }\n\n  private initProps(props?: Prop<P>) {\n    if (!props) {\n      return;\n    }\n    if (typeof props === \"function\") {\n      this.propsFunc = props as () => P;\n      this.props = (props as () => P)();\n    } else {\n      this.props = props;\n      this.propsFunc = () => props;\n    }\n  }\n\n  private updateChain(): void {\n    this.didUpdate();\n    if (this.parent && this.parent instanceof Component) {\n      this.parent.updateChain();\n    }\n  }\n\n  // register children\n  private register(): void {\n    // replace\n    this.replaceSlotWithChild(this.lastComponentsSnapshot);\n  }\n\n  private mount(): void {\n    this.register();\n    this.didMount();\n    this.mounted = true;\n  }\n\n  private patch(el: HTMLElement): void {\n    const diffResult: any = dd.diff(this.ref, el);\n    dd.apply(this.ref, diffResult);\n    // chain effect\n    this.updateChain();\n  }\n}\n","import Component from \"./Component\";\nexport function render(\n  el: string,\n  RootComponent: new (option: { el: string }) => Component\n) {\n  return new RootComponent({ el }).init();\n}\n","import { store } from \"./store\";\nimport Component from \"../core/Component\";\n\ntype IStateResult<StateType = any> = [\n  () => StateType,\n  (newState: StateType) => any\n];\n\nexport function useState<StateType = any>(\n  initialState: StateType\n): IStateResult<StateType> {\n  const { activeComponent, stateList: list } = store;\n  const index: number = list.length;\n  const result: IStateResult<StateType> = [\n    () => {\n      if (!activeComponent) {\n        return initialState;\n      }\n      const hasState = !!activeComponent.state;\n      if (!hasState) {\n        return initialState;\n      }\n      return (activeComponent.state as {\n        [index: number]: StateType;\n      })[index];\n    },\n    (newState: any) => {\n      if (!activeComponent) {\n        return;\n      }\n      (activeComponent as Component).setState({\n        [index]: newState\n      });\n    }\n  ];\n  list.push(initialState);\n  return result;\n}\n","export default function insertBefore(\n  ref: HTMLElement,\n  newDom: HTMLElement\n): void {\n  if (\"jQuery\" in window) {\n    $(newDom).insertBefore(ref);\n    return;\n  }\n  const parent: HTMLElement | null = ref.parentElement;\n  if (!parent) {\n    return;\n  }\n  parent.insertBefore(newDom, ref);\n}\n","export default function insertAfter(\n  ref: HTMLElement,\n  newDom: HTMLElement\n): void {\n  if (\"jQuery\" in window) {\n    $(newDom).insertAfter(ref);\n    return;\n  }\n  const parent: HTMLElement | null = ref.parentElement;\n  if (!parent) {\n    return;\n  }\n  const next: Element | null = ref.nextElementSibling;\n  if (!next) {\n    parent.appendChild(newDom);\n  } else {\n    parent.insertBefore(newDom, next);\n  }\n}\n","export default function removeDom(dom: Element): void {\n  if (\"jQuery\" in window) {\n    $(dom).remove();\n    return;\n  }\n  const parent: HTMLElement | null = dom.parentElement;\n  if (!parent) {\n    return;\n  }\n  parent.removeChild(dom);\n}\n","import { store } from \"./store\";\nimport Component from \"../core/Component\";\n\nconst defaultFn = () => void 0;\n\ntype EffectHook = (ref: HTMLElement) => any;\n\nexport function useEffect(didMountHook: EffectHook) {\n  const { activeComponent, effectList } = store;\n  if (!activeComponent || activeComponent.mounted) {\n    return;\n  }\n  let result = defaultFn;\n  function didMount() {\n    const ref: HTMLElement = (activeComponent as Component).ref;\n    result = didMountHook(ref);\n  }\n  function willUnMount() {\n    if (typeof result === \"function\") {\n      result();\n    }\n  }\n  effectList.push([didMount, willUnMount]);\n}\n","import { store } from \"./store\";\nimport { IComponentsRawHash } from \"../core/Component\";\n\nexport const register = (components: () => IComponentsRawHash): void => {\n  if (!store.activeComponent) {\n    return;\n  }\n  store.activeComponent.components = components;\n};\n"],"names":["diffcount","foundAll","Diff","[object Object]","options","Object","entries","forEach","key","value","this","JSON","stringify","aKey","aValue","elementDescriptors","el","output","nodeName","push","attributes","replace","id","findUniqueDescriptors","li","uniqueDescriptors","duplicateDescriptors","node","descriptor","inUnique","uniqueInBoth","l1","l2","l1Unique","l2Unique","inBoth","keys","removeDone","tree","outerDone","innerDone","valueDone","childNodes","every","isEqual","e1","e2","element","Boolean","e1Attributes","e2Attributes","length","attribute","childNode","index","roughlyEqual","sameSiblings","preventRecursion","data","nodeList1","slice","reverse","nodeList2","childUniqueDescriptors","cloneObj","obj","parse","findCommonSubsets","c1","c2","marked1","marked2","lcsSize","c1Length","c2Length","matches","Array","map","subsetsSame","some","i","c1Desc","c2Desc","description","c1Index","c1Element","c2Index","c2Element","oldValue","newValue","makeArray","n","v","swap","p1","p2","tmp","DiffTracker","list","diffs","fn","input","prototype","toString","call","isObj","sort","reduce","last","ref","filterOutFn","findSame","left","right","item","itemStr","findIndex","rightItem","const","regProducer","domParser","dom","window","$","result","match","trim","tag","innerHTML","Error","document","createElement","attr","_","values","setAttribute","replaceDom","refDom","newDoms","newDomsArr","isArray","extraDoms","replaceWith","parent","parentElement","newDom","insertBefore","removeChild","selectDom","selector","context","find","querySelector","predict","store","activeComponent","componentArray","stateList","effectList","components","makeState","clear","dd","debug","diffcap","maxDepth","maxChildCount","maxChildDiffCount","valueDiffing","textDiff","arguments","preVirtualDiffApply","postVirtualDiffApply","preDiffApply","postDiffApply","filterOuterDiff","compress","varNames","_const","varName","t1Node","t2Node","t1","nodeToObj","t2","t1Orig","t2Orig","tracker","findDiffs","diffError","findNextDiff","console","error","log","add","applyVirtual","route","fdiffs","findOuterDiff","findInnerDiff","findValueDiff","attr1","attr2","attrLength","pos","setValue","action","replaceElement","childNodesLength","childDiffCount","j","modifyTextElement","modifyComment","indexOf","removeAttribute","name","splice","modifyAttribute","addAttribute","aNode","objNode","dobj","nodeArray","undefined","checked","type","includes","toLowerCase","selected","insideSvg","attributeArray","childNodeArray","createTextNode","createComment","createElementNS","appendChild","objToNode","subtrees","subsets","subsetsAge","oldTree","newTree","oldChildren","newChildren","subset","returnIndex","markBoth","markSubTrees","t1ChildNodes","t2ChildNodes","childNodesLengthDifference","attemptGroupRelocation","Math","max","removeTextElement","concat","removeElement","addTextElement","addElement","gapInformation","stable","gaps1","gaps2","group","endOld","endNew","getGapInformation","destinationDifferent","toGroup","similarNode","testI","shortest","min","index2","index1","relocateGroup","from","to","modifySelected","modifyValue","modifyChecked","diff","applyVirtualDiff","parentNode","nodeIndex","routeInfo","getFromVirtualRoute","newSubsets","info","newNode","c","groupLength","movedNode","splitLength","delete","filter","applyDiff","reference","getFromRoute","nodeType","replaceChild","namespaceURI","undoDiff","filterOutInstance","Component","pair","k","assign","convertFnToClass","component","fnComponent","init","constructor","option","renderOption","initProps","props","render","RootComponent","useState","initialState","state","newState","setState","preRenderForFunction","lastComponentsSnapshot","safeComponents","update","lastRenderSnapshot","didMount","didUpdate","willUnMount","shouldUpdate","mounted","preRenderResult","stateToIterate","changed","hasChanged","updateSelf","shouldUpdateSelf","lastRef","html","hasChildren","replaceSlotWithChild","patch","mount","propsFunc","updateChildren","hash","oldHash","oldComponent","initChild","oldLen","len","compareArray","start","leftLen","rightLen","samePair","del","oldC","target","oldEl","newC","insertAfter","next","nextElementSibling","isEmpty","remove","removeDom","child","pop","isRegister","ref$1","outerHTML","manualResult","updateChain","register","diffResult","apply","defaultFn","useEffect","didMountHook"],"mappings":"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"}