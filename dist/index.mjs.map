{"version":3,"file":"index.mjs","sources":["../node_modules/diff-dom/diffDOM.js","../src/util/compareArray.ts","../src/util/matchEl.ts","../src/util/domParser.ts","../src/util/replaceDom.ts","../src/util/selectDom.ts","../src/util/filterObject.ts","../src/hooks/store.ts","../src/core/Component.ts","../src/core/render.ts","../src/hooks/useState.ts","../src/util/insertBefore.ts","../src/util/insertAfter.ts","../src/util/removeDom.ts","../src/hooks/useEffect.ts"],"sourcesContent":["(function(root, factory) {\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = factory();\n        } else {\n            exports.diffDOM = factory();\n        }\n    } else if (typeof define === 'function') {\n        // AMD loader\n        define(factory);\n    } else {\n        // `window` in the browser, or `exports` on the server\n        root.diffDOM = factory();\n    }\n})(this, function() {\n    \"use strict\";\n\n    var diffcount, foundAll = false;\n\n    var Diff = function(options) {\n        var diff = this;\n        if (options) {\n            var keys = Object.keys(options),\n                length = keys.length,\n                i;\n            for (i = 0; i < length; i++) {\n                diff[keys[i]] = options[keys[i]];\n            }\n        }\n\n    };\n\n    Diff.prototype = {\n        toString: function() {\n            return JSON.stringify(this);\n        },\n        setValue: function(aKey, aValue) {\n            this[aKey] = aValue;\n            return this;\n        }\n    };\n\n\n\n    var elementDescriptors = function(el) {\n        var output = [];\n        if (el.nodeName !== '#text' && el.nodeName !== '#comment') {\n            output.push(el.nodeName);\n            if (el.attributes) {\n                if (el.attributes['class']) {\n                    output.push(el.nodeName + '.' + el.attributes['class'].replace(/ /g, '.'));\n                }\n                if (el.attributes.id) {\n                    output.push(el.nodeName + '#' + el.attributes.id);\n                }\n            }\n\n        }\n        return output;\n    };\n\n    var findUniqueDescriptors = function(li) {\n        var uniqueDescriptors = {},\n            duplicateDescriptors = {},\n            liLength = li.length,\n            nodeLength, node, descriptors, descriptor, inUnique, inDupes, i, j;\n\n        for (i = 0; i < liLength; i++) {\n            node = li[i];\n            nodeLength = node.length;\n            descriptors = elementDescriptors(node);\n            for (j = 0; j < nodeLength; j++) {\n                descriptor = descriptors[j];\n                inUnique = descriptor in uniqueDescriptors;\n                inDupes = descriptor in duplicateDescriptors;\n                if (!inUnique && !inDupes) {\n                    uniqueDescriptors[descriptor] = true;\n                } else if (inUnique) {\n                    delete uniqueDescriptors[descriptor];\n                    duplicateDescriptors[descriptor] = true;\n                }\n            }\n        }\n\n        return uniqueDescriptors;\n    };\n\n    var uniqueInBoth = function(l1, l2) {\n        var l1Unique = findUniqueDescriptors(l1),\n            l2Unique = findUniqueDescriptors(l2),\n            inBoth = {},\n            keys = Object.keys(l1Unique),\n            length = keys.length,\n            key,\n            i;\n\n        for (i = 0; i < length; i++) {\n            key = keys[i];\n            if (l2Unique[key]) {\n                inBoth[key] = true;\n            }\n        }\n\n        return inBoth;\n    };\n\n    var removeDone = function(tree) {\n        delete tree.outerDone;\n        delete tree.innerDone;\n        delete tree.valueDone;\n        if (tree.childNodes) {\n            return tree.childNodes.every(removeDone);\n        } else {\n            return true;\n        }\n    };\n\n    var isEqual = function(e1, e2) {\n\n        var e1Attributes, e2Attributes;\n\n        if (!['nodeName', 'value', 'checked', 'selected', 'data'].every(function(element) {\n                if (e1[element] !== e2[element]) {\n                    return false;\n                }\n                return true;\n            })) {\n            return false;\n        }\n\n        if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\n            return false;\n        }\n\n        if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\n            return false;\n        }\n        if (e1.attributes) {\n            e1Attributes = Object.keys(e1.attributes);\n            e2Attributes = Object.keys(e2.attributes);\n\n            if (e1Attributes.length !== e2Attributes.length) {\n                return false;\n            }\n            if (!e1Attributes.every(function(attribute) {\n                    if (e1.attributes[attribute] !== e2.attributes[attribute]) {\n                        return false;\n                    }\n                    return true;\n                })) {\n                return false;\n            }\n        }\n        if (e1.childNodes) {\n            if (e1.childNodes.length !== e2.childNodes.length) {\n                return false;\n            }\n            if (!e1.childNodes.every(function(childNode, index) {\n                    return isEqual(childNode, e2.childNodes[index]);\n                })) {\n\n                return false;\n            }\n\n        }\n\n        return true;\n\n    };\n\n\n    var roughlyEqual = function(e1, e2, uniqueDescriptors, sameSiblings, preventRecursion) {\n        var childUniqueDescriptors, nodeList1, nodeList2;\n\n        if (!e1 || !e2) {\n            return false;\n        }\n\n        if (e1.nodeName !== e2.nodeName) {\n            return false;\n        }\n\n        if (e1.nodeName === '#text') {\n            // Note that we initially don't care what the text content of a node is,\n            // the mere fact that it's the same tag and \"has text\" means it's roughly\n            // equal, and then we can find out the true text difference later.\n            return preventRecursion ? true : e1.data === e2.data;\n        }\n\n\n        if (e1.nodeName in uniqueDescriptors) {\n            return true;\n        }\n\n        if (e1.attributes && e2.attributes) {\n\n            if (e1.attributes.id) {\n                if (e1.attributes.id !== e2.attributes.id) {\n                    return false;\n                } else {\n                    var idDescriptor = e1.nodeName + '#' + e1.attributes.id;\n                    if (idDescriptor in uniqueDescriptors) {\n                        return true;\n                    }\n                }\n            }\n            if (e1.attributes['class'] && e1.attributes['class'] === e2.attributes['class']) {\n                var classDescriptor = e1.nodeName + '.' + e1.attributes['class'].replace(/ /g, '.');\n                if (classDescriptor in uniqueDescriptors) {\n                    return true;\n                }\n            }\n        }\n\n        if (sameSiblings) {\n            return true;\n        }\n\n        nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : [];\n        nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : [];\n\n        if (nodeList1.length !== nodeList2.length) {\n            return false;\n        }\n\n        if (preventRecursion) {\n            return nodeList1.every(function(element, index) {\n                return element.nodeName === nodeList2[index].nodeName;\n            });\n        } else {\n            // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n            // was not set, we must explicitly force it to true for child iterations.\n            childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2);\n            return nodeList1.every(function(element, index) {\n                return roughlyEqual(element, nodeList2[index], childUniqueDescriptors, true, true);\n            });\n        }\n    };\n\n\n    var cloneObj = function(obj) {\n        //  TODO: Do we really need to clone here? Is it not enough to just return the original object?\n        return JSON.parse(JSON.stringify(obj));\n    };\n\n    /**\n     * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n     */\n    var findCommonSubsets = function(c1, c2, marked1, marked2) {\n        var lcsSize = 0,\n            index = [],\n            c1Length = c1.length,\n            c2Length = c2.length,\n            matches = Array.apply(null, new Array(c1Length + 1)).map(function() {\n                return [];\n            }), // set up the matching table\n            uniqueDescriptors = uniqueInBoth(c1, c2),\n            // If all of the elements are the same tag, id and class, then we can\n            // consider them roughly the same even if they have a different number of\n            // children. This will reduce removing and re-adding similar elements.\n            subsetsSame = c1Length === c2Length,\n            origin, ret, c1Index, c2Index, c1Element, c2Element;\n\n        if (subsetsSame) {\n\n            c1.some(function(element, i) {\n                var c1Desc = elementDescriptors(element),\n                    c2Desc = elementDescriptors(c2[i]);\n                if (c1Desc.length !== c2Desc.length) {\n                    subsetsSame = false;\n                    return true;\n                }\n                c1Desc.some(function(description, i) {\n                    if (description !== c2Desc[i]) {\n                        subsetsSame = false;\n                        return true;\n                    }\n                });\n                if (!subsetsSame) {\n                    return true;\n                }\n\n            });\n        }\n\n        // fill the matches with distance values\n        for (c1Index = 0; c1Index < c1Length; c1Index++) {\n            c1Element = c1[c1Index];\n            for (c2Index = 0; c2Index < c2Length; c2Index++) {\n                c2Element = c2[c2Index];\n                if (!marked1[c1Index] && !marked2[c2Index] && roughlyEqual(c1Element, c2Element, uniqueDescriptors, subsetsSame)) {\n                    matches[c1Index + 1][c2Index + 1] = (matches[c1Index][c2Index] ? matches[c1Index][c2Index] + 1 : 1);\n                    if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\n                        lcsSize = matches[c1Index + 1][c2Index + 1];\n                        index = [c1Index + 1, c2Index + 1];\n                    }\n                } else {\n                    matches[c1Index + 1][c2Index + 1] = 0;\n                }\n            }\n        }\n\n        if (lcsSize === 0) {\n            return false;\n        }\n\n        return {\n            oldValue: index[0] - lcsSize,\n            newValue: index[1] - lcsSize,\n            length: lcsSize\n        };\n    };\n\n    /**\n     * This should really be a predefined function in Array...\n     */\n    var makeArray = function(n, v) {\n        return Array.apply(null, new Array(n)).map(function() {\n            return v;\n        });\n    };\n\n    /**\n     * Generate arrays that indicate which node belongs to which subset,\n     * or whether it's actually an orphan node, existing in only one\n     * of the two trees, rather than somewhere in both.\n     *\n     * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n     * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n     * The second longest is \"<img>\" (length 1), so it will be group 1.\n     * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n     *\n     * If an element is not part of any group, it will stay being 'true', which\n     * is the initial value. For example:\n     * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n     *\n     * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n     * therefore be marked by \"true\". The remaining parts are parts of the\n     * groups 0 and 1:\n     * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n     *\n     */\n    var getGapInformation = function(t1, t2, stable) {\n\n        var gaps1 = t1.childNodes ? makeArray(t1.childNodes.length, true) : [],\n            gaps2 = t2.childNodes ? makeArray(t2.childNodes.length, true) : [],\n            group = 0,\n            length = stable.length,\n            i, j, endOld, endNew, subset;\n\n        // give elements from the same subset the same group number\n        for (i = 0; i < length; i++) {\n            subset = stable[i];\n            endOld = subset.oldValue + subset.length;\n            endNew = subset.newValue + subset.length;\n            for (j = subset.oldValue; j < endOld; j += 1) {\n                gaps1[j] = group;\n            }\n            for (j = subset.newValue; j < endNew; j += 1) {\n                gaps2[j] = group;\n            }\n            group += 1;\n        }\n\n        return {\n            gaps1: gaps1,\n            gaps2: gaps2\n        };\n    };\n\n    /**\n     * Find all matching subsets, based on immediate child differences only.\n     */\n    var markSubTrees = function(oldTree, newTree) {\n        // note: the child lists are views, and so update as we update old/newTree\n        var oldChildren = oldTree.childNodes ? oldTree.childNodes : [],\n            newChildren = newTree.childNodes ? newTree.childNodes : [],\n            marked1 = makeArray(oldChildren.length, false),\n            marked2 = makeArray(newChildren.length, false),\n            subsets = [],\n            subset = true,\n            returnIndex = function() {\n                return arguments[1];\n            },\n            markBoth = function(i) {\n                marked1[subset.oldValue + i] = true;\n                marked2[subset.newValue + i] = true;\n            },\n            length, subsetArray, i;\n\n        while (subset) {\n            subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2);\n            if (subset) {\n                subsets.push(subset);\n                subsetArray = Array.apply(null, new Array(subset.length)).map(returnIndex);\n                length = subsetArray.length;\n                for (i = 0; i < length; i++) {\n                    markBoth(subsetArray[i]);\n                }\n            }\n        }\n\n        oldTree.subsets = subsets;\n        oldTree.subsetsAge = 100;\n        return subsets;\n    };\n\n\n    function swap(obj, p1, p2) {\n        var tmp = obj[p1];\n        obj[p1] = obj[p2];\n        obj[p2] = tmp;\n    }\n\n\n    var DiffTracker = function() {\n        this.list = [];\n    };\n\n    DiffTracker.prototype = {\n        list: false,\n        add: function(diffs) {\n            this.list.push.apply(this.list, diffs);\n        },\n        forEach: function(fn) {\n            var length = this.list.length,\n                i;\n            for (i = 0; i < length; i++) {\n                fn(this.list[i]);\n            }\n        }\n    };\n\n    var diffDOM = function(options) {\n\n        var defaults = {\n                debug: false,\n                diffcap: 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n                maxDepth: false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n                maxChildCount: 50, // False or a numeral. If set to a numeral, does not try to diff the contents of nodes with more children if there are more than maxChildDiffCount differences among child nodes.\n                maxChildDiffCount: 3, // Numeral. See maxChildCount.\n                valueDiffing: true, // Whether to take into consideration the values of forms that differ from auto assigned values (when a user fills out a form).\n                // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\n                textDiff: function() {\n                    arguments[0].data = arguments[3];\n                    return;\n                },\n                // empty functions were benchmarked as running faster than both\n                // `f && f()` and `if (f) { f(); }`\n                preVirtualDiffApply: function() {},\n                postVirtualDiffApply: function() {},\n                preDiffApply: function() {},\n                postDiffApply: function() {},\n                filterOuterDiff: null,\n                compress: false // Whether to work with compressed diffs\n            },\n            varNames, i, j;\n\n        if (typeof options === \"undefined\") {\n            options = {};\n        }\n\n        for (i in defaults) {\n            if (typeof options[i] === \"undefined\") {\n                this[i] = defaults[i];\n            } else {\n                this[i] = options[i];\n            }\n        }\n\n        var varNames = {\n            'addAttribute': 'addAttribute',\n            'modifyAttribute': 'modifyAttribute',\n            'removeAttribute': 'removeAttribute',\n            'modifyTextElement': 'modifyTextElement',\n            'relocateGroup': 'relocateGroup',\n            'removeElement': 'removeElement',\n            'addElement': 'addElement',\n            'removeTextElement': 'removeTextElement',\n            'addTextElement': 'addTextElement',\n            'replaceElement': 'replaceElement',\n            'modifyValue': 'modifyValue',\n            'modifyChecked': 'modifyChecked',\n            'modifySelected': 'modifySelected',\n            'modifyComment': 'modifyComment',\n            'action': 'action',\n            'route': 'route',\n            'oldValue': 'oldValue',\n            'newValue': 'newValue',\n            'element': 'element',\n            'group': 'group',\n            'from': 'from',\n            'to': 'to',\n            'name': 'name',\n            'value': 'value',\n            'data': 'data',\n            'attributes': 'attributes',\n            'nodeName': 'nodeName',\n            'childNodes': 'childNodes',\n            'checked': 'checked',\n            'selected': 'selected'\n        };\n\n        if (this.compress) {\n            j = 0;\n            this._const = {};\n            for (i in varNames) {\n                this._const[i] = j;\n                j++;\n            }\n        } else {\n            this._const = varNames;\n        }\n    };\n\n    diffDOM.Diff = Diff;\n\n    diffDOM.prototype = {\n\n        // ===== Create a diff =====\n\n        diff: function(t1Node, t2Node) {\n\n            var t1 = this.nodeToObj(t1Node),\n                t2 = this.nodeToObj(t2Node);\n\n            diffcount = 0;\n\n            if (this.debug) {\n                this.t1Orig = this.nodeToObj(t1Node);\n                this.t2Orig = this.nodeToObj(t2Node);\n            }\n\n            this.tracker = new DiffTracker();\n            return this.findDiffs(t1, t2);\n        },\n        findDiffs: function(t1, t2) {\n            var diffs;\n            do {\n                if (this.debug) {\n                    diffcount += 1;\n                    if (diffcount > this.diffcap) {\n                        window.diffError = [this.t1Orig, this.t2Orig];\n                        throw new Error(\"surpassed diffcap:\" + JSON.stringify(this.t1Orig) + \" -> \" + JSON.stringify(this.t2Orig));\n                    }\n                }\n                diffs = this.findNextDiff(t1, t2, []);\n\n                if (diffs.length === 0) {\n                    // Last check if the elements really are the same now.\n                    // If not, remove all info about being done and start over.\n                    // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                    if (!isEqual(t1, t2)) {\n                        if (foundAll) {\n                            console.error('Could not find remaining diffs!');\n                            console.log({t1, t2});\n                        } else {\n                            foundAll = true;\n                            removeDone(t1);\n                            diffs = this.findNextDiff(t1, t2, []);\n                        }\n                    }\n                }\n                if (diffs.length > 0) {\n                    foundAll = false\n                    this.tracker.add(diffs);\n                    this.applyVirtual(t1, diffs);\n                }\n            } while (diffs.length > 0);\n            return this.tracker.list;\n        },\n        findNextDiff: function(t1, t2, route) {\n            var diffs, fdiffs;\n\n            if (this.maxDepth && route.length > this.maxDepth) {\n                return [];\n            }\n            // outer differences?\n            if (!t1.outerDone) {\n                diffs = this.findOuterDiff(t1, t2, route);\n                if (this.filterOuterDiff) {\n                    fdiffs = this.filterOuterDiff(t1, t2, diffs);\n                    if (fdiffs) diffs = fdiffs;\n                }\n                if (diffs.length > 0) {\n                    t1.outerDone = true;\n                    return diffs;\n                } else {\n                    t1.outerDone = true;\n                }\n            }\n            // inner differences?\n            if (!t1.innerDone) {\n                diffs = this.findInnerDiff(t1, t2, route);\n                if (diffs.length > 0) {\n                    return diffs;\n                } else {\n                    t1.innerDone = true;\n                }\n            }\n\n            if (this.valueDiffing && !t1.valueDone) {\n                // value differences?\n                diffs = this.findValueDiff(t1, t2, route);\n\n                if (diffs.length > 0) {\n                    t1.valueDone = true;\n                    return diffs;\n                } else {\n                    t1.valueDone = true;\n                }\n            }\n\n            // no differences\n            return [];\n        },\n        findOuterDiff: function(t1, t2, route) {\n            var t = this;\n            var diffs = [],\n                attr,\n                attr1, attr2, attrLength, pos, i;\n\n            if (t1.nodeName !== t2.nodeName) {\n                return [new Diff()\n                    .setValue(t._const.action, t._const.replaceElement)\n                    .setValue(t._const.oldValue, cloneObj(t1))\n                    .setValue(t._const.newValue, cloneObj(t2))\n                    .setValue(t._const.route, route)\n                ];\n            }\n\n            if (route.length && this.maxChildCount && t1.childNodes && t2.childNodes && t1.childNodes.length >  this.maxChildCount && t2.childNodes.length > this.maxChildCount) {\n                var childNodesLength = t1.childNodes.length < t2.childNodes.length ? t1.childNodes.length : t2.childNodes.length, childDiffCount = 0,  j = 0;\n                while (childDiffCount < this.maxChildDiffCount && j < childNodesLength) {\n                    if (!isEqual(t1.childNodes[j], t2.childNodes[j])) {\n                        childDiffCount++;\n                    }\n                    j++;\n                }\n                if (childDiffCount === this.maxChildDiffCount) {\n                    return [new Diff()\n                        .setValue(t._const.action, t._const.replaceElement)\n                        .setValue(t._const.oldValue, cloneObj(t1))\n                        .setValue(t._const.newValue, cloneObj(t2))\n                        .setValue(t._const.route, route)\n                    ];\n                }\n            }\n\n            if (t1.data !== t2.data) {\n                // Comment or text node.\n                if (t1.nodeName === '#text') {\n                    return [new Diff()\n                        .setValue(t._const.action, t._const.modifyTextElement)\n                        .setValue(t._const.route, route)\n                        .setValue(t._const.oldValue, t1.data)\n                        .setValue(t._const.newValue, t2.data)\n                    ];\n                } else {\n                    return [new Diff()\n                        .setValue(t._const.action, t._const.modifyComment)\n                        .setValue(t._const.route, route)\n                        .setValue(t._const.oldValue, t1.data)\n                        .setValue(t._const.newValue, t2.data)\n                    ];\n                }\n\n            }\n\n\n            attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : [];\n            attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : [];\n\n            attrLength = attr1.length;\n            for (i = 0; i < attrLength; i++) {\n                attr = attr1[i];\n                pos = attr2.indexOf(attr);\n                if (pos === -1) {\n                    diffs.push(new Diff()\n                        .setValue(t._const.action, t._const.removeAttribute)\n                        .setValue(t._const.route, route)\n                        .setValue(t._const.name, attr)\n                        .setValue(t._const.value, t1.attributes[attr])\n                    );\n                } else {\n                    attr2.splice(pos, 1);\n                    if (t1.attributes[attr] !== t2.attributes[attr]) {\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.modifyAttribute)\n                            .setValue(t._const.route, route)\n                            .setValue(t._const.name, attr)\n                            .setValue(t._const.oldValue, t1.attributes[attr])\n                            .setValue(t._const.newValue, t2.attributes[attr])\n                        );\n                    }\n                }\n            }\n\n            attrLength = attr2.length;\n            for (i = 0; i < attrLength; i++) {\n                attr = attr2[i];\n                diffs.push(new Diff()\n                    .setValue(t._const.action, t._const.addAttribute)\n                    .setValue(t._const.route, route)\n                    .setValue(t._const.name, attr)\n                    .setValue(t._const.value, t2.attributes[attr])\n                );\n            }\n\n            return diffs;\n        },\n        nodeToObj: function(aNode) {\n            var objNode = {},\n                dobj = this,\n                nodeArray, childNode, length, attribute, i;\n            objNode.nodeName = aNode.nodeName;\n            if (objNode.nodeName === '#text' || objNode.nodeName === '#comment') {\n                objNode.data = aNode.data;\n            } else {\n                if (aNode.attributes && aNode.attributes.length > 0) {\n                    objNode.attributes = {};\n                    nodeArray = Array.prototype.slice.call(aNode.attributes);\n                    length = nodeArray.length;\n                    for (i = 0; i < length; i++) {\n                        attribute = nodeArray[i];\n                        objNode.attributes[attribute.name] = attribute.value;\n                    }\n                }\n                if (objNode.nodeName === 'TEXTAREA') {\n                    objNode.value = aNode.value;\n                } else if (aNode.childNodes && aNode.childNodes.length > 0) {\n                    objNode.childNodes = [];\n                    nodeArray = Array.prototype.slice.call(aNode.childNodes);\n                    length = nodeArray.length;\n                    for (i = 0; i < length; i++) {\n                        childNode = nodeArray[i];\n                        objNode.childNodes.push(dobj.nodeToObj(childNode));\n                    }\n                }\n                if (this.valueDiffing) {\n                    if (aNode.checked !== undefined && aNode.type &&\n                        ['radio','checkbox'].indexOf(aNode.type.toLowerCase()) !== -1\n                    ) {\n                        objNode.checked = aNode.checked;\n                    } else if (aNode.value !== undefined) {\n                        objNode.value = aNode.value;\n                    }\n                    if (aNode.selected !== undefined) {\n                        objNode.selected = aNode.selected;\n                    }\n                }\n            }\n            return objNode;\n        },\n        objToNode: function(objNode, insideSvg) {\n            var node, dobj = this,\n                attribute, attributeArray, childNode, childNodeArray, length, i;\n            if (objNode.nodeName === '#text') {\n                node = document.createTextNode(objNode.data);\n\n            } else if (objNode.nodeName === '#comment') {\n                node = document.createComment(objNode.data);\n            } else {\n                if (objNode.nodeName === 'svg' || insideSvg) {\n                    node = document.createElementNS('http://www.w3.org/2000/svg', objNode.nodeName);\n                    insideSvg = true;\n                } else {\n                    node = document.createElement(objNode.nodeName);\n                }\n                if (objNode.attributes) {\n                    attributeArray = Object.keys(objNode.attributes);\n                    length = attributeArray.length;\n                    for (i = 0; i < length; i++) {\n                        attribute = attributeArray[i];\n                        node.setAttribute(attribute, objNode.attributes[attribute]);\n                    }\n                }\n                if (objNode.childNodes) {\n                    childNodeArray = objNode.childNodes;\n                    length = childNodeArray.length;\n                    for (i = 0; i < length; i++) {\n                        childNode = childNodeArray[i];\n                        node.appendChild(dobj.objToNode(childNode, insideSvg));\n                    }\n                }\n                if (this.valueDiffing) {\n                    if (objNode.value) {\n                        node.value = objNode.value;\n                    }\n                    if (objNode.checked) {\n                        node.checked = objNode.checked;\n                    }\n                    if (objNode.selected) {\n                        node.selected = objNode.selected;\n                    }\n                }\n            }\n            return node;\n        },\n        findInnerDiff: function(t1, t2, route) {\n            var oldSubsets = t1.subsets;\n            //var subtrees = (t1.childNodes && t2.childNodes) ?  markSubTrees(t1, t2) : [],\n            var subtrees = t1.subsets && t1.subsetsAge-- ? t1.subsets : (t1.childNodes && t2.childNodes) ?  markSubTrees(t1, t2) : [],\n                t1ChildNodes = t1.childNodes ? t1.childNodes : [],\n                t2ChildNodes = t2.childNodes ? t2.childNodes : [],\n                childNodesLengthDifference, diffs = [],\n                index = 0, t = this,\n                last, e1, e2, i;\n\n            if (subtrees.length > 0) {\n                /* One or more groups have been identified among the childnodes of t1\n                 * and t2.\n                 */\n                diffs = this.attemptGroupRelocation(t1, t2, subtrees, route);\n                if (diffs.length > 0) {\n                    return diffs;\n                }\n            }\n\n            /* 0 or 1 groups of similar child nodes have been found\n             * for t1 and t2. 1 If there is 1, it could be a sign that the\n             * contents are the same. When the number of groups is below 2,\n             * t1 and t2 are made to have the same length and each of the\n             * pairs of child nodes are diffed.\n             */\n\n\n            last = Math.max(t1ChildNodes.length, t2ChildNodes.length);\n            if (t1ChildNodes.length !== t2ChildNodes.length) {\n                childNodesLengthDifference = true;\n            }\n\n            for (i = 0; i < last; i += 1) {\n                e1 = t1ChildNodes[i];\n                e2 = t2ChildNodes[i];\n\n                if (childNodesLengthDifference) {\n                    /* t1 and t2 have different amounts of childNodes. Add\n                     * and remove as necessary to obtain the same length */\n                    if (e1 && !e2) {\n                        if (e1.nodeName === '#text') {\n                            diffs.push(new Diff()\n                                .setValue(t._const.action, t._const.removeTextElement)\n                                .setValue(t._const.route, route.concat(index))\n                                .setValue(t._const.value, e1.data)\n                            );\n                            index -= 1;\n                        } else {\n                            diffs.push(new Diff()\n                                .setValue(t._const.action, t._const.removeElement)\n                                .setValue(t._const.route, route.concat(index))\n                                .setValue(t._const.element, cloneObj(e1))\n                            );\n                            index -= 1;\n                        }\n\n                    } else if (e2 && !e1) {\n                        if (e2.nodeName === '#text') {\n                            diffs.push(new Diff()\n                                .setValue(t._const.action, t._const.addTextElement)\n                                .setValue(t._const.route, route.concat(index))\n                                .setValue(t._const.value, e2.data)\n                            );\n                        } else {\n                            diffs.push(new Diff()\n                                .setValue(t._const.action, t._const.addElement)\n                                .setValue(t._const.route, route.concat(index))\n                                .setValue(t._const.element, cloneObj(e2))\n                            );\n                        }\n                    }\n                }\n                /* We are now guaranteed that childNodes e1 and e2 exist,\n                 * and that they can be diffed.\n                 */\n                /* Diffs in child nodes should not affect the parent node,\n                 * so we let these diffs be submitted together with other\n                 * diffs.\n                 */\n\n                if (e1 && e2) {\n                    diffs = diffs.concat(this.findNextDiff(e1, e2, route.concat(index)));\n                }\n\n                index += 1;\n\n            }\n            t1.innerDone = true;\n            return diffs;\n\n        },\n\n        attemptGroupRelocation: function(t1, t2, subtrees, route) {\n            /* Either t1.childNodes and t2.childNodes have the same length, or\n             * there are at least two groups of similar elements can be found.\n             * attempts are made at equalizing t1 with t2. First all initial\n             * elements with no group affiliation (gaps=true) are removed (if\n             * only in t1) or added (if only in t2). Then the creation of a group\n             * relocation diff is attempted.\n             */\n            var t = this;\n            var gapInformation = getGapInformation(t1, t2, subtrees),\n                gaps1 = gapInformation.gaps1,\n                gaps2 = gapInformation.gaps2,\n                shortest = Math.min(gaps1.length, gaps2.length),\n                destinationDifferent, toGroup,\n                group, node, similarNode, testI, diffs = [],\n                index1, index2, j;\n\n\n            for (index2 = 0, index1 = 0; index2 < shortest; index1 += 1, index2 += 1) {\n                if (gaps1[index2] === true) {\n                    node = t1.childNodes[index1];\n                    if (node.nodeName === '#text') {\n                        if (t2.childNodes[index2].nodeName === '#text' && node.data !== t2.childNodes[index2].data) {\n                            testI = index1;\n                            while (t1.childNodes.length > testI + 1 && t1.childNodes[testI + 1].nodeName === '#text') {\n                                testI += 1;\n                                if (t2.childNodes[index2].data === t1.childNodes[testI].data) {\n                                    similarNode = true;\n                                    break;\n                                }\n                            }\n                            if (!similarNode) {\n                                diffs.push(new Diff()\n                                    .setValue(t._const.action, t._const.modifyTextElement)\n                                    .setValue(t._const.route, route.concat(index2))\n                                    .setValue(t._const.oldValue, node.data)\n                                    .setValue(t._const.newValue, t2.childNodes[index2].data)\n                                );\n                                return diffs;\n                            }\n                        }\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.removeTextElement)\n                            .setValue(t._const.route, route.concat(index2))\n                            .setValue(t._const.value, node.data)\n                        );\n                        gaps1.splice(index2, 1);\n                        shortest = Math.min(gaps1.length, gaps2.length);\n                        index2 -= 1;\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.removeElement)\n                            .setValue(t._const.route, route.concat(index2))\n                            .setValue(t._const.element, cloneObj(node))\n                        );\n                        gaps1.splice(index2, 1);\n                        shortest = Math.min(gaps1.length, gaps2.length);\n                        index2 -= 1;\n                    }\n\n                } else if (gaps2[index2] === true) {\n                    node = t2.childNodes[index2];\n                    if (node.nodeName === '#text') {\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.addTextElement)\n                            .setValue(t._const.route, route.concat(index2))\n                            .setValue(t._const.value, node.data)\n                        );\n                        gaps1.splice(index2, 0, true);\n                        shortest = Math.min(gaps1.length, gaps2.length);\n                        index1 -= 1;\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.addElement)\n                            .setValue(t._const.route, route.concat(index2))\n                            .setValue(t._const.element, cloneObj(node))\n                        );\n                        gaps1.splice(index2, 0, true);\n                        shortest = Math.min(gaps1.length, gaps2.length);\n                        index1 -= 1;\n                    }\n\n                } else if (gaps1[index2] !== gaps2[index2]) {\n                    if (diffs.length > 0) {\n                        return diffs;\n                    }\n                    // group relocation\n                    group = subtrees[gaps1[index2]];\n                    toGroup = Math.min(group.newValue, (t1.childNodes.length - group.length));\n                    if (toGroup !== group.oldValue) {\n                        // Check whether destination nodes are different than originating ones.\n                        destinationDifferent = false;\n                        for (j = 0; j < group.length; j += 1) {\n                            if (!roughlyEqual(t1.childNodes[toGroup + j], t1.childNodes[group.oldValue + j], [], false, true)) {\n                                destinationDifferent = true;\n                            }\n                        }\n                        if (destinationDifferent) {\n                            return [new Diff()\n                                .setValue(t._const.action, t._const.relocateGroup)\n                                .setValue('groupLength', group.length)\n                                .setValue(t._const.from, group.oldValue)\n                                .setValue(t._const.to, toGroup)\n                                .setValue(t._const.route, route)\n                            ];\n                        }\n                    }\n                }\n            }\n            return diffs;\n        },\n\n        findValueDiff: function(t1, t2, route) {\n            // Differences of value. Only useful if the value/selection/checked value\n            // differs from what is represented in the DOM. For example in the case\n            // of filled out forms, etc.\n            var diffs = [];\n            var t = this;\n\n            if (t1.selected !== t2.selected) {\n                diffs.push(new Diff()\n                    .setValue(t._const.action, t._const.modifySelected)\n                    .setValue(t._const.oldValue, t1.selected)\n                    .setValue(t._const.newValue, t2.selected)\n                    .setValue(t._const.route, route)\n                );\n            }\n\n            if ((t1.value || t2.value) && t1.value !== t2.value && t1.nodeName !== 'OPTION') {\n                diffs.push(new Diff()\n                    .setValue(t._const.action, t._const.modifyValue)\n                    .setValue(t._const.oldValue, t1.value || \"\")\n                    .setValue(t._const.newValue, t2.value || \"\")\n                    .setValue(t._const.route, route)\n                );\n            }\n            if (t1.checked !== t2.checked) {\n                diffs.push(new Diff()\n                    .setValue(t._const.action, t._const.modifyChecked)\n                    .setValue(t._const.oldValue, t1.checked)\n                    .setValue(t._const.newValue, t2.checked)\n                    .setValue(t._const.route, route)\n                );\n            }\n\n            return diffs;\n        },\n\n        // ===== Apply a virtual diff =====\n\n        applyVirtual: function(tree, diffs) {\n            var dobj = this,\n                length = diffs.length,\n                diff, i;\n            if (length === 0) {\n                return true;\n            }\n            for (i = 0; i < length; i++) {\n                diff = diffs[i];\n                dobj.applyVirtualDiff(tree, diff);\n            }\n            return true;\n        },\n        getFromVirtualRoute: function(tree, route) {\n            var node = tree,\n                parentNode, nodeIndex;\n\n            route = route.slice();\n            while (route.length > 0) {\n                if (!node.childNodes) {\n                    return false;\n                }\n                nodeIndex = route.splice(0, 1)[0];\n                parentNode = node;\n                node = node.childNodes[nodeIndex];\n            }\n            return {\n                node: node,\n                parentNode: parentNode,\n                nodeIndex: nodeIndex\n            };\n        },\n        applyVirtualDiff: function(tree, diff) {\n            var routeInfo = this.getFromVirtualRoute(tree, diff[this._const.route]),\n                node = routeInfo.node,\n                parentNode = routeInfo.parentNode,\n                nodeIndex = routeInfo.nodeIndex,\n                newSubsets = [], splitLength,\n                newNode, movedNode, nodeArray, route, length, c, i;\n\n            var t = this;\n            // pre-diff hook\n            var info = {\n                diff: diff,\n                node: node\n            };\n\n            if (this.preVirtualDiffApply(info)) {\n                return true;\n            }\n\n            switch (diff[this._const.action]) {\n                case this._const.addAttribute:\n                    if (!node.attributes) {\n                        node.attributes = {};\n                    }\n\n                    node.attributes[diff[this._const.name]] = diff[this._const.value];\n\n                    if (diff[this._const.name] === 'checked') {\n                        node.checked = true;\n                    } else if (diff[this._const.name] === 'selected') {\n                        node.selected = true;\n                    } else if (node.nodeName === 'INPUT' && diff[this._const.name] === 'value') {\n                        node.value = diff[this._const.value];\n                    }\n\n                    break;\n                case this._const.modifyAttribute:\n                    node.attributes[diff[this._const.name]] = diff[this._const.newValue];\n                    break;\n                case this._const.removeAttribute:\n\n                    delete node.attributes[diff[this._const.name]];\n\n                    if (Object.keys(node.attributes).length === 0) {\n                        delete node.attributes;\n                    }\n\n                    if (diff[this._const.name] === 'checked') {\n                        node.checked = false;\n                    } else if (diff[this._const.name] === 'selected') {\n                        delete node.selected;\n                    } else if (node.nodeName === 'INPUT' && diff[this._const.name] === 'value') {\n                        delete node.value;\n                    }\n\n                    break;\n                case this._const.modifyTextElement:\n                    node.data = diff[this._const.newValue];\n                    break;\n                case this._const.modifyValue:\n                    node.value = diff[this._const.newValue];\n                    break;\n                case this._const.modifyComment:\n                    node.data = diff[this._const.newValue];\n                    break;\n                case this._const.modifyChecked:\n                    node.checked = diff[this._const.newValue];\n                    break;\n                case this._const.modifySelected:\n                    node.selected = diff[this._const.newValue];\n                    break;\n                case this._const.replaceElement:\n                    newNode = cloneObj(diff[this._const.newValue]);\n                    newNode.outerDone = true;\n                    newNode.innerDone = true;\n                    newNode.valueDone = true;\n                    parentNode.childNodes[nodeIndex] = newNode;\n                    break;\n                case this._const.relocateGroup:\n                    nodeArray = node.childNodes.splice(diff[this._const.from], diff.groupLength).reverse();\n                    length = nodeArray.length;\n                    for (i = 0; i < length; i++) {\n                        movedNode = nodeArray[i];\n                        node.childNodes.splice(diff[t._const.to], 0, movedNode);\n                    }\n                    if (node.subsets) {\n\n                        node.subsets.forEach(function(map) {\n                            if (diff[t._const.from] < diff[t._const.to] && map.oldValue <= diff[t._const.to] && map.oldValue > diff[t._const.from]) {\n                                map.oldValue -= diff.groupLength;\n                                splitLength = map.oldValue + map.length - diff[t._const.to];\n                                if (splitLength > 0) {\n                                    // new insertion splits map.\n                                    newSubsets.push({\n                                        oldValue: diff[t._const.to] + diff.groupLength,\n                                        newValue: map.newValue + map.length - splitLength,\n                                        length: splitLength\n                                    })\n                                    map.length -= splitLength;\n                                }\n                            } else if (diff[t._const.from] > diff[t._const.to] && map.oldValue > diff[t._const.to] && map.oldValue < diff[t._const.from]) {\n                                map.oldValue += diff.groupLength;\n                                splitLength = map.oldValue + map.length - diff[t._const.to];\n                                if (splitLength > 0) {\n                                    // new insertion splits map.\n                                    newSubsets.push({\n                                        oldValue: diff[t._const.to] + diff.groupLength,\n                                        newValue: map.newValue + map.length - splitLength,\n                                        length: splitLength\n                                    })\n                                    map.length -= splitLength;\n                                }\n                            } else if (map.oldValue === diff[t._const.from]) {\n                                map.oldValue = diff[t._const.to];\n                            }\n                        });\n                    }\n\n                    break;\n                case this._const.removeElement:\n                    parentNode.childNodes.splice(nodeIndex, 1);\n                    if (parentNode.subsets) {\n                        parentNode.subsets.forEach(function(map) {\n                            if (map.oldValue > nodeIndex) {\n                                map.oldValue -= 1;\n                            } else if (map.oldValue === nodeIndex) {\n                                map.delete = true;\n                            } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                                if (map.oldValue + map.length - 1 === nodeIndex) {\n                                    map.length--;\n                                } else {\n                                    newSubsets.push({\n                                        newValue: map.newValue + nodeIndex - map.oldValue,\n                                        oldValue: nodeIndex,\n                                        length: map.length - nodeIndex + map.oldValue - 1\n                                    })\n                                    map.length = nodeIndex - map.oldValue\n                                }\n                            }\n                        });\n                    }\n                    node = parentNode;\n                    break;\n                case this._const.addElement:\n                    route = diff[this._const.route].slice();\n                    c = route.splice(route.length - 1, 1)[0];\n                    node = this.getFromVirtualRoute(tree, route).node;\n                    newNode = cloneObj(diff[this._const.element]);\n                    newNode.outerDone = true;\n                    newNode.innerDone = true;\n                    newNode.valueDone = true;\n\n                    if (!node.childNodes) {\n                        node.childNodes = [];\n                    }\n\n                    if (c >= node.childNodes.length) {\n                        node.childNodes.push(newNode);\n                    } else {\n                        node.childNodes.splice(c, 0, newNode);\n                    }\n                    if (node.subsets) {\n                        node.subsets.forEach(function(map) {\n                            if (map.oldValue >= c) {\n                                map.oldValue += 1;\n                            } else if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                                splitLength = map.oldValue + map.length - c\n                                newSubsets.push({\n                                    newValue: map.newValue + map.length - splitLength,\n                                    oldValue: c + 1,\n                                    length: splitLength\n                                })\n                                map.length -= splitLength\n                            }\n                        });\n                    }\n                    break;\n                case this._const.removeTextElement:\n                    parentNode.childNodes.splice(nodeIndex, 1);\n                    if (parentNode.nodeName === 'TEXTAREA') {\n                        delete parentNode.value;\n                    }\n                    if (parentNode.subsets) {\n                        parentNode.subsets.forEach(function(map) {\n                            if (map.oldValue > nodeIndex) {\n                                map.oldValue -= 1;\n                            } else if (map.oldValue === nodeIndex) {\n                                map.delete = true;\n                            } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                                if (map.oldValue + map.length - 1 === nodeIndex) {\n                                    map.length--;\n                                } else {\n                                    newSubsets.push({\n                                        newValue: map.newValue + nodeIndex - map.oldValue,\n                                        oldValue: nodeIndex,\n                                        length: map.length - nodeIndex + map.oldValue - 1\n                                    })\n                                    map.length = nodeIndex - map.oldValue\n                                }\n                            }\n                        });\n                    }\n                    node = parentNode;\n                    break;\n                case this._const.addTextElement:\n                    route = diff[this._const.route].slice();\n                    c = route.splice(route.length - 1, 1)[0];\n                    newNode = {};\n                    newNode.nodeName = '#text';\n                    newNode.data = diff[this._const.value];\n                    node = this.getFromVirtualRoute(tree, route).node;\n                    if (!node.childNodes) {\n                        node.childNodes = [];\n                    }\n\n                    if (c >= node.childNodes.length) {\n                        node.childNodes.push(newNode);\n                    } else {\n                        node.childNodes.splice(c, 0, newNode);\n                    }\n                    if (node.nodeName === 'TEXTAREA') {\n                        node.value = diff[this._const.newValue];\n                    }\n                    if (node.subsets) {\n                        node.subsets.forEach(function(map) {\n                            if (map.oldValue >= c) {\n                                map.oldValue += 1;\n                            } if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                                splitLength = map.oldValue + map.length - c\n                                newSubsets.push({\n                                    newValue: map.newValue + map.length - splitLength,\n                                    oldValue: c + 1,\n                                    length: splitLength\n                                })\n                                map.length -= splitLength\n                            }\n                        });\n                    }\n                    break;\n                default:\n                    console.log('unknown action');\n            }\n\n            if (node.subsets) {\n                node.subsets = node.subsets.filter(function(map) {\n                    return !map.delete && map.oldValue !== map.newValue;\n                });\n                if (newSubsets.length) {\n                    node.subsets = node.subsets.concat(newSubsets);\n                }\n            }\n\n            // capture newNode for the callback\n            info.newNode = newNode;\n            this.postVirtualDiffApply(info);\n\n            return;\n        },\n\n\n\n\n        // ===== Apply a diff =====\n\n        apply: function(tree, diffs) {\n            var dobj = this,\n                length = diffs.length,\n                diff, i;\n\n            if (length === 0) {\n                return true;\n            }\n            for (i = 0; i < length; i++) {\n                diff = diffs[i];\n                if (!dobj.applyDiff(tree, diff)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        getFromRoute: function(tree, route) {\n            route = route.slice();\n            var c, node = tree;\n            while (route.length > 0) {\n                if (!node.childNodes) {\n                    return false;\n                }\n                c = route.splice(0, 1)[0];\n                node = node.childNodes[c];\n            }\n            return node;\n        },\n        applyDiff: function(tree, diff) {\n            var node = this.getFromRoute(tree, diff[this._const.route]),\n                newNode, reference, route, nodeArray, length, childNode, index, c;\n\n            var t = this;\n            // pre-diff hook\n            var info = {\n                diff: diff,\n                node: node\n            };\n\n            if (this.preDiffApply(info)) {\n                return true;\n            }\n\n            switch (diff[this._const.action]) {\n                case this._const.addAttribute:\n                    if (!node || !node.setAttribute) {\n                        return false;\n                    }\n                    node.setAttribute(diff[this._const.name], diff[this._const.value]);\n                    break;\n                case this._const.modifyAttribute:\n                    if (!node || !node.setAttribute) {\n                        return false;\n                    }\n                    node.setAttribute(diff[this._const.name], diff[this._const.newValue]);\n                    if (diff[this._const.name] === 'value' && node.nodeName === 'INPUT' && node.value !== diff[this._const.oldValue]) {\n                        node.value = diff[this._const.oldValue];\n                    }\n                    break;\n                case this._const.removeAttribute:\n                    if (!node || !node.removeAttribute) {\n                        return false;\n                    }\n                    node.removeAttribute(diff[this._const.name]);\n                    break;\n                case this._const.modifyTextElement:\n                    if (!node || node.nodeType !== 3) {\n                        return false;\n                    }\n                    this.textDiff(node, node.data, diff[this._const.oldValue], diff[this._const.newValue]);\n                    break;\n                case this._const.modifyValue:\n                    if (!node || typeof node.value === 'undefined') {\n                        return false;\n                    }\n                    node.value = diff[this._const.newValue];\n                    break;\n                case this._const.modifyComment:\n                    if (!node || typeof node.data === 'undefined') {\n                        return false;\n                    }\n                    this.textDiff(node, node.data, diff[this._const.oldValue], diff[this._const.newValue]);\n                    break;\n                case this._const.modifyChecked:\n                    if (!node || typeof node.checked === 'undefined') {\n                        return false;\n                    }\n                    node.checked = diff[this._const.newValue];\n                    break;\n                case this._const.modifySelected:\n                    if (!node || typeof node.selected === 'undefined') {\n                        return false;\n                    }\n                    node.selected = diff[this._const.newValue];\n                    break;\n                case this._const.replaceElement:\n                    node.parentNode.replaceChild(this.objToNode(diff[this._const.newValue], node.namespaceURI === 'http://www.w3.org/2000/svg'), node);\n                    break;\n                case this._const.relocateGroup:\n                    nodeArray = Array.apply(null, new Array(diff.groupLength)).map(function() {\n                        return node.removeChild(node.childNodes[diff[t._const.from]]);\n                    });\n                    length = nodeArray.length;\n                    for (index = 0; index < length; index++) {\n                        childNode = nodeArray[index];\n                        if (index === 0) {\n                            reference = node.childNodes[diff[t._const.to]];\n                        }\n                        node.insertBefore(childNode, reference || null);\n                    }\n                    break;\n                case this._const.removeElement:\n                    node.parentNode.removeChild(node);\n                    break;\n                case this._const.addElement:\n                    route = diff[this._const.route].slice();\n                    c = route.splice(route.length - 1, 1)[0];\n                    node = this.getFromRoute(tree, route);\n                    node.insertBefore(this.objToNode(diff[this._const.element], node.namespaceURI === 'http://www.w3.org/2000/svg'), node.childNodes[c] || null);\n                    break;\n                case this._const.removeTextElement:\n                    if (!node || node.nodeType !== 3) {\n                        return false;\n                    }\n                    node.parentNode.removeChild(node);\n                    break;\n                case this._const.addTextElement:\n                    route = diff[this._const.route].slice();\n                    c = route.splice(route.length - 1, 1)[0];\n                    newNode = document.createTextNode(diff[this._const.value]);\n                    node = this.getFromRoute(tree, route);\n                    if (!node || !node.childNodes) {\n                        return false;\n                    }\n                    node.insertBefore(newNode, node.childNodes[c] || null);\n                    break;\n                default:\n                    console.log('unknown action');\n            }\n\n            // if a new node was created, we might be interested in it\n            // post diff hook\n            info.newNode = newNode;\n            this.postDiffApply(info);\n\n            return true;\n        },\n\n        // ===== Undo a diff =====\n\n        undo: function(tree, diffs) {\n            var dobj = this, diff, length = diffs.length, i;\n            diffs = diffs.slice();\n            if (!length) {\n                diffs = [diffs];\n            }\n            diffs.reverse();\n            for (i = 0; i < length; i++) {\n                diff = diffs[i];\n                dobj.undoDiff(tree, diff);\n            }\n        },\n        undoDiff: function(tree, diff) {\n\n            switch (diff[this._const.action]) {\n                case this._const.addAttribute:\n                    diff[this._const.action] = this._const.removeAttribute;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyAttribute:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.removeAttribute:\n                    diff[this._const.action] = this._const.addAttribute;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyTextElement:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyValue:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyComment:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyChecked:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifySelected:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.replaceElement:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.relocateGroup:\n                    swap(diff, this._const.from, this._const.to);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.removeElement:\n                    diff[this._const.action] = this._const.addElement;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.addElement:\n                    diff[this._const.action] = this._const.removeElement;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.removeTextElement:\n                    diff[this._const.action] = this._const.addTextElement;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.addTextElement:\n                    diff[this._const.action] = this._const.removeTextElement;\n                    this.applyDiff(tree, diff);\n                    break;\n                default:\n                    console.log('unknown action');\n            }\n\n        }\n    };\n\n    return diffDOM;\n});\n","export interface IDiff {\n  index: number;\n  oldValue: any;\n  newValue: any;\n  type: diffType;\n}\n\n// edit/add/delete\ntype diffType = \"E\" | \"A\" | \"D\";\n\n// no more function\nfunction filterOutFn(input: object): object {\n  return Object.entries(input).reduce((last, [key, value]) => {\n    if (typeof value === \"function\") {\n      return last;\n    }\n    return {\n      ...last,\n      [key]: value\n    };\n  }, {});\n}\n\n// sort object\n// ! for edge cases\nfunction sort(input: { [index: string]: any }): {} {\n  return Object.keys(input)\n    .sort()\n    .reduce((last, key) => {\n      return {\n        ...last,\n        [key]: input[key]\n      };\n    }, {});\n}\n\n// is object\nfunction isObj(input: any): boolean {\n  return Object.prototype.toString.call(input) === \"[object Object]\";\n}\n\n// safe stringify\nfunction stringify(input: any): string {\n  if (isObj(input)) {\n    return JSON.stringify(sort(filterOutFn(input)));\n  }\n  return JSON.stringify(input);\n}\n\n// find same element\nfunction findSame(left: any[], right: any[]): Array<[number, number]> {\n  return left.reduce((last: number[], item, i) => {\n    const itemStr = stringify(item);\n    const index: number = right.findIndex(\n      rightItem => stringify(rightItem) === itemStr\n    );\n    if (index > -1) {\n      return [...last, [i, index]];\n    }\n  }, []) as Array<[number, number]>;\n}\n\n// simple diff for array\nexport default function compareArray(\n  left: any[],\n  right: any[],\n  start: number = 0\n): IDiff[] {\n  const leftLen: number = left.length;\n  const rightLen: number = right.length;\n  if (leftLen === rightLen) {\n    return left.reduce((last: IDiff[], item, i) => {\n      const rightItem: any = right[i];\n      if (typeof item === \"function\" && typeof rightItem === \"function\") {\n        return last;\n      }\n      const leftStr: string = stringify(item);\n      const rightStr: string = stringify(rightItem);\n      if (leftStr !== rightStr) {\n        return [\n          ...last,\n          {\n            index: i + start,\n            oldValue: item,\n            newValue: rightItem,\n            type: \"E\"\n          }\n        ];\n      }\n      return last;\n    }, []);\n  } else if (leftLen > rightLen) {\n    // delete\n    if (rightLen === 0) {\n      return left.map((item, i) => {\n        return {\n          index: i + start,\n          oldValue: item,\n          newValue: undefined,\n          type: \"D\"\n        };\n      }) as IDiff[];\n    } else {\n      const samePair: Array<[number, number]> = findSame(left, right);\n      // just delete?\n      const isJustDel: boolean = samePair.length === rightLen;\n      // update + delete\n      if (!isJustDel) {\n        return compareArray(left.slice(0, rightLen), right).concat(\n          compareArray(left.slice(rightLen), [], rightLen)\n        );\n      }\n      return left.reduce((last, item, i) => {\n        const hasSame: boolean = samePair.some(\n          ([leftIndex]) => leftIndex === i\n        );\n        if (hasSame) {\n          return last;\n        }\n        return {\n          index: i + start,\n          oldValue: item,\n          newValue: undefined,\n          type: \"D\"\n        };\n      }, []);\n    }\n  } else {\n    // add\n    if (leftLen === 0) {\n      return right.map((item, i) => {\n        return {\n          index: i + start,\n          oldValue: undefined,\n          newValue: item,\n          type: \"A\"\n        };\n      }) as IDiff[];\n    } else {\n      const samePair: Array<[number, number]> = findSame(left, right);\n      // just add?\n      const isJustAdd: boolean = samePair.length === leftLen;\n      if (!isJustAdd) {\n        return compareArray(left, right.slice(0, leftLen)).concat(\n          compareArray([], right.slice(leftLen), leftLen)\n        );\n      }\n      return right.reduce((last, item, i) => {\n        const hasSame: boolean = samePair.some(\n          ([_, rightIndex]) => rightIndex === i\n        );\n        if (hasSame) {\n          return last;\n        }\n        return [\n          ...last,\n          {\n            index: i + start,\n            oldValue: undefined,\n            newValue: item,\n            type: \"A\"\n          }\n        ];\n      }, []) as IDiff[];\n    }\n  }\n}\n","const regProducer = (): RegExp =>\n  /^<([a-z]+)([^>]*?)(\\/?>|(>([\\s\\S]*?)<\\/\\1>))$/i;\nexport default function matchEl(\n  input: string\n): {\n  tag: string;\n  attributes: string;\n  innerHTML: string;\n} | null {\n  const result = input.match(regProducer());\n  if (!result) {\n    return null;\n  }\n  return {\n    tag: result[1],\n    attributes: result[2] || \"\",\n    innerHTML: result[5] || \"\"\n  };\n}\n","import matchEl from \"./matchEl\";\nexport default function domParser(dom: string): HTMLElement {\n  if (\"jQuery\" in window) {\n    return $(dom)[0];\n  }\n  const match = matchEl(dom.trim());\n  if (!match) {\n    throw new Error(`source: ${dom}; Not a valid element! check render()`);\n  }\n  const el = document.createElement(match.tag);\n  el.innerHTML = match.innerHTML;\n  const { attributes } = match;\n  if (attributes) {\n    const attr: { [index: string]: string } = {};\n    attributes\n      .trim()\n      .replace(/([a-zA-Z]+)=([^'\"]+|(['\"])([^'\"]+)\\3)/g, (_, key, values) => {\n        attr[key] = values.replace(/['\"]/g, \"\");\n        return _;\n      });\n    Object.entries(attr).forEach(([k, v]) => {\n      el.setAttribute(k, v);\n    });\n  }\n  return el;\n}\n","export default function replaceDom(\n  refDom: HTMLElement,\n  newDoms: HTMLElement | HTMLElement[],\n  ...extraDoms: HTMLElement[]\n): void {\n  const newDomsArr: HTMLElement[] = Array.isArray(newDoms)\n    ? [...newDoms, ...extraDoms]\n    : [newDoms, ...extraDoms];\n  if (\"jQuery\" in window) {\n    $(refDom).replaceWith(newDomsArr);\n    return;\n  }\n  const parent: HTMLElement | null = refDom.parentElement;\n  if (!parent) {\n    return;\n  }\n  if (!newDomsArr.length) {\n    throw new Error(\"Need to provide new DOM!\");\n  }\n  let ref: HTMLElement = refDom;\n  for (let i = newDomsArr.length - 1; i >= 0; i--) {\n    const newDom: HTMLElement = newDomsArr[i];\n    parent.insertBefore(newDom, ref);\n    ref = newDom;\n  }\n  parent.removeChild(refDom);\n}\n","export default function selectDom(\n  selector: string,\n  context: HTMLElement | Document = document\n): HTMLElement | null {\n  if (\"jQuery\" in window) {\n    return $(context as HTMLElement).find(selector)[0];\n  } else {\n    return context.querySelector(selector);\n  }\n}\n","const filterObject = <T extends object = {}>(\n  predict: <K extends keyof T>(pair: [K, T[K]], source: T) => boolean\n) => (obj: T): Partial<T> => {\n  return Object.entries(obj).reduce((last: Partial<T>, pair) => {\n    const [k, v] = pair as [keyof T, T[keyof T]];\n    if (predict([k, v], obj)) {\n      return Object.assign(last, { [k]: v });\n    }\n    return last;\n  }, {});\n};\n\nexport default filterObject;\n","import Component from \"../core/Component\";\n\ninterface IStore {\n  activeComponent: Component<any, any> | null;\n  componentArray: Component[];\n  stateList: any[];\n  effectList: any[];\n  makeState: () => { [index: number]: any };\n}\n\nexport const store: IStore = {\n  activeComponent: null,\n  componentArray: [],\n  stateList: [],\n  effectList: [],\n  makeState() {\n    return store.stateList.reduce((last, item, index) => {\n      return {\n        ...last,\n        [index]: item\n      };\n    }, {});\n  }\n};\n","import DiffDOM from \"diff-dom\";\nimport compareArray, { IDiff } from \"../util/compareArray\";\nimport domParser from \"../util/domParser\";\nimport replaceDom from \"../util/replaceDom\";\nimport insertBefore from \"../util/insertBefore\";\nimport insertAfter from \"../util/insertAfter\";\nimport removeDom from \"../util/removeDom\";\nimport filterObj from \"../util/filterObject\";\nimport selectDom from \"../util/selectDom\";\nimport { store } from \"../hooks/store\";\nconst config = {\n  logDiff: false\n};\nconst dd = new DiffDOM({\n  preVirtualDiffApply(info: any) {\n    if (!config.logDiff) {\n      return;\n    }\n    console.log(info);\n  },\n  preDiffApply(info: { diff: { action: string } }) {\n    if (info.diff.action === \"modifyValue\") {\n      return true;\n    }\n  }\n});\n\n// filter out Component\nconst filterOutInstance = filterObj(([_, v]) => {\n  const isInstance: boolean = (v as any) instanceof Component;\n  return !isInstance;\n});\n\ninterface IObj {\n  [index: string]: any;\n}\n// props type\ntype Prop<P> = (() => P) | P;\ninterface IProp<P> {\n  props?: Prop<P>;\n}\n\ntype FnComponent = () => string;\n\n// For components method, accept both Base and FnComponent\ninterface IComponentsRawHash {\n  [name: string]: Component | FnComponent | Array<Component | FnComponent>;\n}\n\n// convert all components to Base | Base[]\ninterface IComponentsHash {\n  [name: string]: Component | Component[];\n}\n\ninterface IComponentOption<P> extends IProp<P> {\n  el?: string;\n  fnComponent?: FnComponent;\n}\n\n// convert functional component to class\nconst convertFnToClass = (component: Component | FnComponent): Component => {\n  if (component instanceof Component) {\n    return component;\n  }\n  return new Component({\n    fnComponent: component\n  }).init();\n};\n\nexport default class Component<P extends IObj = {}, S extends IObj = {}> {\n  public ref!: HTMLElement;\n  public parent: Component<any, any> | null = null;\n  public renderOption!: IComponentOption<P>;\n  public state!: Readonly<S>;\n  public props: P = {} as P;\n  public lastRenderSnapshot: string = \"\";\n  public lastComponentsSnapshot: IComponentsHash = {};\n  public mounted: boolean = false;\n  constructor(option: IComponentOption<P> = {}) {\n    // cache option\n    this.renderOption = option;\n    this.initProps(option.props);\n  }\n\n  // constructor -> render -> didMount\n  public init() {\n    // cache result\n    this.lastComponentsSnapshot = this.safeComponents();\n    // update DOM\n    this.update();\n    // cache render\n    this.lastRenderSnapshot = this.render();\n    return this;\n  }\n\n  public components(): IComponentsRawHash {\n    return {};\n  }\n\n  public didMount(): void {\n    return;\n  }\n\n  public didUpdate(): void {\n    return;\n  }\n\n  public willUnMount(): void {\n    return;\n  }\n\n  public shouldUpdate(): boolean | void {\n    return;\n  }\n\n  public render(props = this.props, state = this.state): string {\n    // handle functional component\n    if (this.renderOption.fnComponent) {\n      // empty hooks\n      store.stateList = [];\n      store.effectList = [];\n      // set active\n      store.activeComponent = this;\n      const result: string = this.renderOption.fnComponent();\n      if (!this.mounted) {\n        this.state = store.makeState() as S;\n        store.stateList = [];\n        if (store.effectList.length) {\n          const [didMount, willUnMount] = store.effectList.pop();\n          if (typeof didMount === \"function\") {\n            this.didMount = didMount;\n          }\n          if (typeof willUnMount === \"function\") {\n            this.willUnMount = willUnMount;\n          }\n        }\n      }\n      return result;\n    }\n    return \"<div></div>\";\n  }\n\n  // update state\n  public setState<K extends keyof S>(\n    state: Pick<S, K> | ((prevState: S) => S)\n  ) {\n    let stateToIterate!: Pick<S, K> | S;\n    if (typeof state === \"function\") {\n      stateToIterate = state(Object.assign({}, this.state));\n    } else {\n      stateToIterate = state;\n    }\n    if (!stateToIterate) {\n      throw new Error(\"invalid state!\");\n    }\n    // skip extra reduce\n    if (typeof state === \"function\") {\n      this.state = stateToIterate as S;\n      return this.update();\n    }\n    const { newState, hasChanged } = Object.entries(stateToIterate).reduce(\n      (\n        last: {\n          newState: Pick<S, K>;\n          hasChanged: boolean;\n        },\n        [key, value]: [string, any]\n      ) => {\n        const hasKey = key in this.state;\n        // discard if didn't exist\n        if (!hasKey) {\n          return last;\n        }\n        const changed: boolean = value !== this.state[key];\n        return {\n          newState: Object.assign(last.newState, { [key]: value }),\n          hasChanged: last.hasChanged || changed\n        };\n      },\n      {\n        hasChanged: false,\n        newState: this.state\n      }\n    );\n    if (hasChanged) {\n      this.state = newState as S;\n      this.update();\n    }\n  }\n\n  // props\n  private propsFunc: () => P = () => ({} as P);\n\n  private updateSelf() {\n    if (!this.shouldUpdateSelf()) {\n      return;\n    }\n    const { el } = this.renderOption;\n    const lastRef: HTMLElement = this.ref;\n    const html: string = this.render();\n    // update render cache\n    this.lastRenderSnapshot = html;\n    // early exit if no result\n    if (!html || !html.trim()) {\n      return;\n    }\n    const element: HTMLElement = domParser(html);\n    if (!lastRef) {\n      // bind ref\n      this.ref = element;\n    } else {\n      if (this.hasChildren()) {\n        // update children first\n        // todo: better solution\n        this.replaceSlotWithChild(this.lastComponentsSnapshot, element, false);\n      }\n      this.patch(element);\n      return;\n    }\n    // only mount root component here\n    const isRoot: boolean = !!el && typeof el === \"string\";\n    if (!isRoot) {\n      return;\n    }\n    (selectDom(el as string) as HTMLElement).appendChild(this.ref);\n    // mount\n    if (!this.mounted) {\n      this.mount();\n    }\n  }\n\n  // update component\n  private update() {\n    this.props = this.propsFunc();\n    this.updateChildren();\n    this.updateSelf();\n  }\n\n  private updateChildren() {\n    const hash: IComponentsHash = this.safeComponents();\n    // no children, early exit\n    if (!this.hasChildren(hash)) {\n      return;\n    }\n    // get last cache\n    const oldHash: IComponentsHash = this.lastComponentsSnapshot;\n    Object.entries(hash).forEach(([name, component]) => {\n      const oldComponent = oldHash[name];\n      // array\n      if (Array.isArray(component) && Array.isArray(oldComponent)) {\n        // init\n        component.forEach(c => this.initChild(c));\n        const oldLen: number = oldComponent.length;\n        const len: number = component.length;\n        // compare props to decide how to update children\n        const oldProps: object[] = oldComponent\n          .map(c => c.props)\n          .map(filterOutInstance);\n        const newProps: object[] = component\n          .map(c => c.props)\n          .map(filterOutInstance);\n        const arrayDiff = compareArray(oldProps, newProps);\n        // get update/add/delete array\n        const { update, add, del } = arrayDiff.reduce(\n          (last: { update: IDiff[]; del: IDiff[]; add: IDiff[] }, item) => {\n            if (item.type === \"E\") {\n              last.update.push(item);\n            }\n            if (item.type === \"D\") {\n              last.del.push(item);\n            }\n            if (item.type === \"A\") {\n              last.add.push(item);\n            }\n            return last;\n          },\n          {\n            update: [],\n            add: [],\n            del: []\n          }\n        );\n        // update has first class priority\n        update.forEach(item => {\n          const { index } = item;\n          const c: Component = component[index];\n          const oldC: Component = oldComponent[index];\n          oldC.propsFunc = c.propsFunc;\n          oldC.update();\n        });\n        // deal with add\n        if (add.length && add.length === len + oldLen) {\n          // 0 -> n\n          const target: HTMLElement | null = selectDom(name, this.ref);\n          if (target) {\n            replaceDom(target, component.map(c => c.ref));\n          }\n          component.forEach(c => c.mount());\n          this.lastComponentsSnapshot[name] = component;\n        } else {\n          const oldEl: HTMLElement[] = oldComponent.map(c => c.ref);\n          add.forEach((item, i) => {\n            const { index } = item;\n            const newC: Component = component[index];\n            // add to middle\n            if (index < oldLen) {\n              insertBefore(oldEl[index], newC.ref);\n              (this.lastComponentsSnapshot[name] as Component[]).splice(\n                index + i,\n                0,\n                newC\n              );\n            } else {\n              // append\n              const ref: HTMLElement =\n                index === oldLen\n                  ? oldComponent[oldLen - 1].ref\n                  : component[index - 1].ref;\n              insertAfter(ref, newC.ref);\n              (this.lastComponentsSnapshot[name] as Component[])[index] = newC;\n            }\n            // mount\n            newC.mount();\n          });\n        }\n        // n -> 0 ?\n        const isEmpty: boolean = del.length === oldLen;\n        // deal with delete\n        del.forEach((item, i) => {\n          const { index } = item;\n          const oldC: Component = oldComponent[index];\n          (this.lastComponentsSnapshot[name] as Component[]).splice(\n            index - i,\n            1\n          );\n          oldC.willUnMount();\n          if (isEmpty && index === oldLen - 1) {\n            return replaceDom(oldC.ref, domParser(name));\n          }\n          removeDom(oldC.ref);\n        });\n      } else if (!Array.isArray(component) && !Array.isArray(oldComponent)) {\n        // update single component\n        oldComponent.propsFunc = component.propsFunc;\n        oldComponent.update();\n      }\n    });\n  }\n\n  private hasChildren(\n    hash: IComponentsHash = this.lastComponentsSnapshot\n  ): boolean {\n    return Object.keys(hash).length > 0;\n  }\n\n  // handle component in function type\n  private safeComponents(): IComponentsHash {\n    return Object.entries(this.components()).reduce(\n      (last: IComponentsHash, [name, component]) => {\n        if (Array.isArray(component)) {\n          last[name] = component.map(convertFnToClass);\n        } else {\n          last[name] = convertFnToClass(component);\n        }\n        return last;\n      },\n      {}\n    );\n  }\n\n  // assign parent\n  private initChild(child: Component) {\n    child.parent = this;\n  }\n\n  // replace custom element with real element\n  private replaceSlotWithChild(\n    components: IComponentsHash,\n    ref: HTMLElement = this.ref,\n    isRegister: boolean = true\n  ) {\n    // not register phase\n    // using existing outerHTML to replace\n    Object.entries(components).forEach(([name, child]) => {\n      let replaceElement: HTMLElement[] | HTMLElement | null = null;\n      if (Array.isArray(child)) {\n        // only assign if has children\n        if (child.length) {\n          child.forEach(c => this.initChild(c));\n          replaceElement = child.map(c => {\n            return isRegister ? c.ref : domParser(c.ref.outerHTML);\n          });\n        }\n      } else {\n        this.initChild(child);\n        // could be no ref if render returns \"\" or null or undefined\n        if (child.ref) {\n          replaceElement = isRegister\n            ? child.ref\n            : domParser(child.ref.outerHTML);\n        }\n      }\n      // if have elements, then replace\n      // or leave it be\n      if (replaceElement) {\n        const target: HTMLElement | null = selectDom(name, ref);\n        if (target) {\n          replaceDom(target, replaceElement);\n        }\n      }\n      // don't trigger mount if it is not register phase\n      if (!isRegister) {\n        return;\n      }\n      // mount\n      if (Array.isArray(child)) {\n        child.forEach(c => {\n          if (c.ref) {\n            c.mount();\n          }\n        });\n      } else {\n        if (child.ref) {\n          child.mount();\n        }\n      }\n    });\n  }\n\n  private shouldUpdateSelf(): boolean {\n    // override\n    const manualResult: boolean | void = this.shouldUpdate();\n    if (typeof manualResult === \"boolean\") {\n      return manualResult;\n    }\n    const renderResult: string = this.render();\n    return renderResult !== this.lastRenderSnapshot;\n  }\n\n  private initProps(props?: Prop<P>) {\n    if (!props) {\n      return;\n    }\n    if (typeof props === \"function\") {\n      this.propsFunc = props as () => P;\n      this.props = (props as () => P)();\n    } else {\n      this.props = props;\n      this.propsFunc = () => props;\n    }\n  }\n\n  private updateChain(): void {\n    this.didUpdate();\n    if (this.parent && this.parent instanceof Component) {\n      this.parent.updateChain();\n    }\n  }\n\n  // register children\n  private register(): void {\n    // replace\n    this.replaceSlotWithChild(this.lastComponentsSnapshot);\n  }\n\n  private mount(): void {\n    this.register();\n    this.didMount();\n    this.mounted = true;\n  }\n\n  private patch(el: HTMLElement): void {\n    const diffResult: any = dd.diff(this.ref, el);\n    dd.apply(this.ref, diffResult);\n    // chain effect\n    this.updateChain();\n  }\n}\n","import Component from \"./Component\";\nexport function render(\n  el: string,\n  RootComponent: { new (option: { el: string }): Component }\n) {\n  return new RootComponent({ el }).init();\n}\n","import { store } from \"./store\";\nimport Component from \"../core/Component\";\n\ntype IStateResult<StateType = any> = [\n  () => StateType,\n  (newState: StateType) => any\n];\n\nexport function useState<StateType = any>(\n  initialState: StateType\n): IStateResult<StateType> {\n  const { activeComponent, stateList: list } = store;\n  const index: number = list.length;\n  const result: IStateResult<StateType> = [\n    () => {\n      if (!activeComponent) {\n        return initialState;\n      }\n      const hasState = !!activeComponent.state;\n      if (!hasState) {\n        return initialState;\n      }\n      return (activeComponent.state as {\n        [index: number]: StateType;\n      })[index];\n    },\n    (newState: any) => {\n      if (!activeComponent) {\n        return;\n      }\n      (activeComponent as Component).setState({\n        [index]: newState\n      });\n    }\n  ];\n  list.push(initialState);\n  return result;\n}\n","export default function insertBefore(\n  ref: HTMLElement,\n  newDom: HTMLElement\n): void {\n  if (\"jQuery\" in window) {\n    $(newDom).insertBefore(ref);\n    return;\n  }\n  const parent: HTMLElement | null = ref.parentElement;\n  if (!parent) {\n    return;\n  }\n  parent.insertBefore(newDom, ref);\n}\n","export default function insertAfter(\n  ref: HTMLElement,\n  newDom: HTMLElement\n): void {\n  if (\"jQuery\" in window) {\n    $(newDom).insertAfter(ref);\n    return;\n  }\n  const parent: HTMLElement | null = ref.parentElement;\n  if (!parent) {\n    return;\n  }\n  const next: Element | null = ref.nextElementSibling;\n  if (!next) {\n    parent.appendChild(newDom);\n  } else {\n    parent.insertBefore(newDom, next);\n  }\n}\n","export default function removeDom(dom: Element): void {\n  if (\"jQuery\" in window) {\n    $(dom).remove();\n    return;\n  }\n  const parent: HTMLElement | null = dom.parentElement;\n  if (!parent) {\n    return;\n  }\n  parent.removeChild(dom);\n}\n","import { store } from \"./store\";\nimport Component from \"../core/Component\";\n\nconst defaultFn = () => {};\n\ntype EffectHook = (ref: HTMLElement) => any;\n\nexport function useEffect(didMountHook: EffectHook) {\n  const { activeComponent, effectList } = store;\n  let result = defaultFn;\n  function didMount() {\n    const ref: HTMLElement = (activeComponent as Component).ref;\n    result = didMountHook(ref);\n  }\n  function willUnMount() {\n    if (typeof result === \"function\") {\n      result();\n    }\n  }\n  effectList.push([didMount, willUnMount]);\n}\n"],"names":["factory","diffcount","foundAll","Diff","options","i","keys","Object","length","this","prototype","toString","JSON","stringify","setValue","aKey","aValue","elementDescriptors","el","output","nodeName","push","attributes","replace","id","findUniqueDescriptors","li","nodeLength","node","descriptors","descriptor","inUnique","j","uniqueDescriptors","duplicateDescriptors","liLength","uniqueInBoth","l1","l2","key","l1Unique","l2Unique","inBoth","removeDone","tree","outerDone","innerDone","valueDone","childNodes","every","isEqual","e1","e2","e1Attributes","e2Attributes","element","Boolean","attribute","childNode","index","roughlyEqual","sameSiblings","preventRecursion","childUniqueDescriptors","nodeList1","nodeList2","data","slice","reverse","cloneObj","obj","parse","findCommonSubsets","c1","c2","marked1","marked2","c1Index","c2Index","c1Element","lcsSize","c1Length","c2Length","matches","Array","apply","map","subsetsSame","some","c1Desc","c2Desc","description","oldValue","newValue","makeArray","n","v","swap","p1","p2","tmp","DiffTracker","list","add","diffs","forEach","fn","diffDOM","defaults","debug","diffcap","maxDepth","maxChildCount","maxChildDiffCount","valueDiffing","textDiff","arguments","preVirtualDiffApply","postVirtualDiffApply","preDiffApply","postDiffApply","filterOuterDiff","compress","varNames","addAttribute","modifyAttribute","removeAttribute","modifyTextElement","relocateGroup","removeElement","addElement","removeTextElement","addTextElement","replaceElement","modifyValue","modifyChecked","modifySelected","modifyComment","action","route","group","from","to","name","value","checked","selected","_const","diff","t1Node","t2Node","t1","nodeToObj","t2","t1Orig","t2Orig","tracker","findDiffs","window","diffError","Error","findNextDiff","console","error","log","applyVirtual","fdiffs","findOuterDiff","findInnerDiff","findValueDiff","attr","attr1","attr2","attrLength","pos","t","childNodesLength","childDiffCount","sort","indexOf","splice","aNode","nodeArray","objNode","call","undefined","type","toLowerCase","objToNode","insideSvg","attributeArray","childNodeArray","document","createTextNode","createComment","createElementNS","createElement","setAttribute","appendChild","childNodesLengthDifference","last","subtrees","subsets","subsetsAge","oldTree","newTree","subsetArray","oldChildren","newChildren","subset","returnIndex","markBoth","markSubTrees","t1ChildNodes","t2ChildNodes","attemptGroupRelocation","Math","max","concat","destinationDifferent","toGroup","similarNode","testI","index1","index2","gapInformation","stable","endOld","endNew","gaps1","gaps2","getGapInformation","shortest","min","applyVirtualDiff","getFromVirtualRoute","parentNode","nodeIndex","splitLength","newNode","c","routeInfo","newSubsets","info","groupLength","delete","filter","applyDiff","getFromRoute","reference","nodeType","replaceChild","namespaceURI","removeChild","insertBefore","undo","undoDiff","module","exports","input","isObj","reduce","entries","ref","filterOutFn","findSame","left","right","item","itemStr","findIndex","rightItem","const","regProducer","domParser","dom","$","result","match","trim","tag","innerHTML","_","values","replaceDom","refDom","newDoms","newDomsArr","isArray","extraDoms","replaceWith","parent","parentElement","newDom","selectDom","selector","context","find","querySelector","predict","store","activeComponent","componentArray","stateList","effectList","makeState","dd","DiffDOM","filterOutInstance","Component","pair","k","assign","convertFnToClass","component","fnComponent","init","constructor","option","renderOption","initProps","props","render","RootComponent","useState","initialState","state","newState","setState","lastComponentsSnapshot","safeComponents","update","lastRenderSnapshot","components","didMount","didUpdate","willUnMount","shouldUpdate","mounted","pop","stateToIterate","changed","hasChanged","updateSelf","shouldUpdateSelf","lastRef","html","hasChildren","replaceSlotWithChild","patch","mount","propsFunc","updateChildren","hash","oldHash","oldComponent","initChild","oldLen","len","compareArray","start","leftLen","rightLen","samePair","del","oldC","target","oldEl","newC","insertAfter","next","nextElementSibling","isEmpty","remove","removeDom","child","isRegister","ref$1","outerHTML","manualResult","updateChain","register","diffResult","defaultFn","useEffect","didMountHook"],"mappings":"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"}